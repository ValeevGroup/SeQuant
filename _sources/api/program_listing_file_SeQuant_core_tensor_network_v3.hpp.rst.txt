
.. _program_listing_file_SeQuant_core_tensor_network_v3.hpp:

Program Listing for File v3.hpp
===============================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_core_tensor_network_v3.hpp>` (``SeQuant/core/tensor_network/v3.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //
   // Created by Eduard Valeyev on 2025-24-07.
   //
   
   #ifndef SEQUANT_TENSOR_NETWORK_V3_H
   #define SEQUANT_TENSOR_NETWORK_V3_H
   
   #include <SeQuant/core/container.hpp>
   #include <SeQuant/core/expr.hpp>
   #include <SeQuant/core/index.hpp>
   #include <SeQuant/core/tensor_network/canonicals.hpp>
   #include <SeQuant/core/tensor_network/slot.hpp>
   #include <SeQuant/core/tensor_network/vertex.hpp>
   #include <SeQuant/core/utility/macros.hpp>
   
   #include <range/v3/range/traits.hpp>
   
   #include <cstdlib>
   #include <iosfwd>
   #include <memory>
   #include <stdexcept>
   #include <string>
   #include <string_view>
   #include <tuple>
   #include <type_traits>
   #include <utility>
   #include <vector>
   
   // forward declarations
   namespace bliss {
   class Graph;
   }
   
   namespace sequant {
   
   
   class TensorNetworkV3 {
    public:
     constexpr static int version() { return 3; }
   
     // for unit testing only
     friend class TensorNetworkV3Accessor;
   
     using Origin = SlotType;
   
     class Vertex {
      public:
       Vertex(Origin origin, std::size_t terminal_idx, std::size_t index_slot,
              Symmetry terminal_symm);
   
       Origin getOrigin() const;
       std::size_t getTerminalIndex() const;
       std::size_t getIndexSlot() const;
       Symmetry getTerminalSymmetry() const;
   
       bool operator<(const Vertex &rhs) const;
       bool operator==(const Vertex &rhs) const;
   
      private:
       Origin origin;
       std::size_t terminal_idx;
       std::size_t index_slot;
       Symmetry terminal_symm;
     };
   
     // clang-format off
   
     // clang-format on
     class Edge {
      public:
       Edge() = default;
       Edge(const Edge &) = delete;
       Edge(Edge &&) = default;
       Edge &operator=(const Edge &) = delete;
       Edge &operator=(Edge &&) = default;
       explicit Edge(const Vertex &vertex) : vertices{vertex} {}
       explicit Edge(std::initializer_list<Vertex> vertices) {
         ranges::for_each(vertices,
                          [this](const Vertex &v) { this->connect_to(v); });
       }
       Edge(const Vertex &vertex, const Index *index)
           : vertices{vertex}, index(index) {}
       Edge(std::initializer_list<Vertex> vertices, const Index *index)
           : Edge(vertices) {
         this->index = index;
       }
   
       Edge &connect_to(const Vertex &vertex) {
         // free Edge
         if (vertices.empty()) {
           vertices.emplace(vertex);
         } else {
           // - can't connect bra slot to bra slot or ket slot to ket slot, unless
           // there is no distinction between primal and dual spaces
           if (get_default_context().braket_symmetry() != BraKetSymmetry::Symm) {
             if (vertex.getOrigin() == Origin::Bra) {
               if (ranges::contains(vertices, Origin::Bra,
                                    [](const auto &v) { return v.getOrigin(); })) {
                 throw std::invalid_argument(
                     "TensorNetworkV3::Edge::connect_to: bra slot can only be "
                     "connected "
                     "to a bra slot if default context's braket_symmetry() != "
                     "BraKetSymmetry::Symm");
               }
             }
             if (vertex.getOrigin() == Origin::Ket) {
               if (ranges::contains(vertices, Origin::Ket,
                                    [](const auto &v) { return v.getOrigin(); })) {
                 throw std::invalid_argument(
                     "TensorNetworkV3::Edge::connect_to: ket slot can only be "
                     "connected "
                     "to a ket slot if default context's braket_symmetry() != "
                     "BraKetSymmetry::Symm");
               }
             }
           }
           add_vertex(vertex);
         }
   
         return *this;
       }
   
       bool operator<(const Edge &other) const {
         if (vertex_count() != other.vertex_count()) {
           // Ensure external indices (edges that are only attached to a tensor on
           // one side) always come before internal ones
           return vertex_count() < other.vertex_count();
         }
   
         if (!(vertices == other.vertices)) {
           return vertices < other.vertices;
         }
   
         SEQUANT_ASSERT(index && other.index);
         return index->space() < other.index->space();
       }
   
       bool operator==(const Edge &other) const {
         return vertices == other.vertices;
       }
   
       const Vertex &vertex(std::size_t i) const {
         SEQUANT_ASSERT(vertices.size() > i);
         return *(vertices.begin() + i);
       }
   
       std::size_t vertex_count() const { return vertices.size(); }
   
       const Index &idx() const {
         SEQUANT_ASSERT(index);
         return *index;
       }
   
      private:
       container::set<Vertex> vertices;
       const Index *index = nullptr;
   
       void add_vertex(const Vertex &vertex) {
         auto [it, inserted] = this->vertices.emplace(vertex);
         if (!inserted)
           throw std::invalid_argument(
               "TensorNetworkV3::Edge::add_vertex(v): v is already connected by "
               "this Edge");
       }
     };
   
     struct Graph {
       using VertexColor = std::uint32_t;
   
       std::unique_ptr<bliss::Graph> bliss_graph;
       std::vector<std::wstring> vertex_labels;
       std::vector<std::optional<std::wstring>> vertex_xlabels;
       std::vector<std::optional<std::wstring>> vertex_texlabels;
       std::vector<VertexColor> vertex_colors;
       std::vector<VertexType> vertex_types;
       container::map<Index, std::size_t> idx_to_vertex;
   
       Graph() = default;
   
       std::size_t vertex_to_index_idx(std::size_t vertex) const;
       std::optional<std::size_t> vertex_to_tensor_idx(std::size_t vertex) const;
     };
   
     TensorNetworkV3(const Expr &expr) {
       if (expr.size() > 0) {
         for (const ExprPtr &subexpr : expr) {
           add_expr(*subexpr);
         }
       } else {
         add_expr(expr);
       }
   
       init_edges();
     }
   
     TensorNetworkV3(const ExprPtr &expr) : TensorNetworkV3(*expr) {}
   
     template <
         typename ExprPtrRange,
         typename = std::enable_if_t<!std::is_base_of_v<ExprPtr, ExprPtrRange> &&
                                     !std::is_base_of_v<Expr, ExprPtrRange>>>
     TensorNetworkV3(const ExprPtrRange &exprptr_range) {
       static_assert(
           std::is_base_of_v<ExprPtr, ranges::range_value_t<ExprPtrRange>>);
       for (const ExprPtr &current : exprptr_range) {
         add_expr(*current);
       }
   
       init_edges();
     }
   
     TensorNetworkV3(TensorNetworkV3 &&) noexcept;
     TensorNetworkV3 &operator=(TensorNetworkV3 &&) noexcept;
   
     TensorNetworkV3(const TensorNetworkV3 &other);
   
     TensorNetworkV3 &operator=(const TensorNetworkV3 &other) noexcept;
   
     const auto &tensors() const { return tensors_; }
   
     const auto &tensor_input_ordinals() const { return tensor_input_ordinals_; }
   
     using NamedIndexSet = container::set<Index, Index::FullLabelCompare>;
   
     ExprPtr canonicalize(
         const container::vector<std::wstring> &cardinal_tensor_labels = {},
         const CanonicalizeOptions &options =
             CanonicalizeOptions::default_options());
   
     struct SlotCanonicalizationMetadata {
       NamedIndexSet named_indices;
   
       using named_index_compare_t =
           std::function<bool(const std::pair<const Index *, IndexSlotType> &,
                              const std::pair<const Index *, IndexSlotType> &)>;
   
       named_index_compare_t named_index_compare;
   
       container::svector<NamedIndexSet::const_iterator> named_indices_canonical;
   
       std::shared_ptr<bliss::Graph> graph;
   
       [[nodiscard]] size_t hash_value() const;
   
       [[nodiscard]] inline auto get_index_view() const {
         return named_indices_canonical  //
                | ranges::views::indirect;
       }
   
       template <typename Cont>
       auto get_indices() const {
         return get_index_view() | ranges::to<Cont>;
       }
   
       std::int8_t phase = +1;  // +1 or -1
     };
   
     SlotCanonicalizationMetadata canonicalize_slots(
         const container::vector<std::wstring> &cardinal_tensor_labels = {},
         const NamedIndexSet *named_indices = nullptr,
         SlotCanonicalizationMetadata::named_index_compare_t named_index_compare =
             default_idxptr_slottype_lesscompare{});
   
     container::svector<std::pair<long, long>> factorize();
   
     const auto &edges() const {
       SEQUANT_ASSERT(have_edges_);
       return edges_;
     }
   
     const auto &ext_indices() const {
       SEQUANT_ASSERT(have_edges_);
       return ext_indices_;
     }
   
     struct CreateGraphOptions {
       const NamedIndexSet *named_indices = nullptr;
   
       bool distinct_named_indices = false;
   
       bool make_labels = true;
   
       bool label_prepend_ordinal = false;
   
       bool make_xlabels = false;
   
       std::function<std::wstring(std::size_t)> xlabel_maker =
           [](std::size_t vertex_ordinal) {
             return std::to_wstring(vertex_ordinal);
           };
   
       bool make_texlabels = true;
   
       bool texlabel_prepend_ordinal = false;
   
       bool make_idx_to_vertex = false;
     };
     static CreateGraphOptions make_default_graph_options() { return {}; }
   
     // clang-format off
   
     // clang-format on
     Graph create_graph(
         const CreateGraphOptions &options = make_default_graph_options()) const;
   
    private:
     container::svector<AbstractTensorPtr> tensors_;
     container::svector<std::size_t> tensor_input_ordinals_;
   
     container::vector<Edge> edges_;
     bool have_edges_ = false;
     NamedIndexSet ext_indices_;
     NamedIndexSet pure_proto_indices_;
   
     void init_edges();
   
     [[nodiscard]] ExprPtr canonicalize_graph(
         const NamedIndexSet &named_indices,
         bool ignore_named_index_labels = true);
   
     ExprPtr canonicalize_individual_tensor_blocks(
         const NamedIndexSet &named_indices);
   
     ExprPtr canonicalize_individual_tensors(const NamedIndexSet &named_indices);
   
     ExprPtr do_individual_canonicalization(
         const TensorCanonicalizer &canonicalizer);
   
     void add_expr(const Expr &expr) {
       ExprPtr clone = expr.clone();
   
       auto tensor_ptr = std::dynamic_pointer_cast<AbstractTensor>(clone);
       if (!tensor_ptr) {
         throw std::invalid_argument(
             "TensorNetworkV3::TensorNetworkV3: tried to add non-tensor to "
             "network");
       }
   
       tensors_.emplace_back(std::move(tensor_ptr));
       tensor_input_ordinals_.push_back(tensor_input_ordinals_.size());
     }
   };
   
   }  // namespace sequant
   
   #endif  // SEQUANT_TENSOR_NETWORK_H


.. _program_listing_file_SeQuant_core_index_space_registry.hpp:

Program Listing for File index_space_registry.hpp
=================================================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_core_index_space_registry.hpp>` (``SeQuant/core/index_space_registry.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //
   // Created by Conner Masteran on 4/16/24.
   //
   
   #ifndef SEQUANT_INDEX_SPACE_REGISTRY_HPP
   #define SEQUANT_INDEX_SPACE_REGISTRY_HPP
   
   #include <SeQuant/core/bitset.hpp>
   #include <SeQuant/core/space.hpp>
   #include <SeQuant/core/utility/macros.hpp>
   #include <SeQuant/core/utility/string.hpp>
   
   #include <range/v3/algorithm/sort.hpp>
   #include <range/v3/numeric/accumulate.hpp>
   #include <range/v3/range/conversion.hpp>
   #include <range/v3/view/filter.hpp>
   #include <range/v3/view/transform.hpp>
   #include <range/v3/view/unique.hpp>
   
   #include <boost/hana.hpp>
   #include <boost/hana/ext/std/integral_constant.hpp>
   
   #include <mutex>
   
   namespace sequant {
   
   inline namespace space_tags {
   struct IsVacuumOccupied {};
   struct IsReferenceOccupied {};
   struct IsComplete {};
   struct IsHole {};
   struct IsParticle {};
   
   constexpr auto is_vacuum_occupied = IsVacuumOccupied{};
   constexpr auto is_reference_occupied = IsReferenceOccupied{};
   constexpr auto is_complete = IsComplete{};
   constexpr auto is_hole = IsHole{};
   constexpr auto is_particle = IsParticle{};
   
   }  // namespace space_tags
   
   // clang-format off
   
   // clang-format on
   class IndexSpaceRegistry {
    public:
     IndexSpaceRegistry()
         : spaces_(std::make_shared<
                   container::set<IndexSpace, IndexSpace::KeyCompare>>()) {
       // register nullspace
       this->add(IndexSpace::null);
     }
   
     IndexSpaceRegistry(
         std::shared_ptr<container::set<IndexSpace, IndexSpace::KeyCompare>>
             spaces)
         : spaces_(std::move(spaces)) {}
   
     IndexSpaceRegistry(const IndexSpaceRegistry& other)
         : spaces_(other.spaces_),
           physical_particle_attribute_mask_(
               other.physical_particle_attribute_mask_),
           vacocc_(other.vacocc_),
           refocc_(other.refocc_),
           complete_(other.complete_),
           hole_space_(other.hole_space_),
           particle_space_(other.particle_space_) {}
   
     IndexSpaceRegistry(IndexSpaceRegistry&& other)
         : spaces_(std::move(other.spaces_)),
           physical_particle_attribute_mask_(
               std::move(other.physical_particle_attribute_mask_)),
           vacocc_(std::move(other.vacocc_)),
           refocc_(std::move(other.refocc_)),
           complete_(std::move(other.complete_)),
           hole_space_(std::move(other.hole_space_)),
           particle_space_(std::move(other.particle_space_)) {}
   
     IndexSpaceRegistry& operator=(const IndexSpaceRegistry& other) {
       spaces_ = other.spaces_;
       physical_particle_attribute_mask_ = other.physical_particle_attribute_mask_;
       vacocc_ = other.vacocc_;
       refocc_ = other.refocc_;
       complete_ = other.complete_;
       hole_space_ = other.hole_space_;
       particle_space_ = other.particle_space_;
       return *this;
     }
   
     IndexSpaceRegistry& operator=(IndexSpaceRegistry&& other) {
       spaces_ = std::move(other.spaces_);
       physical_particle_attribute_mask_ =
           std::move(other.physical_particle_attribute_mask_);
       vacocc_ = std::move(other.vacocc_);
       refocc_ = std::move(other.refocc_);
       complete_ = std::move(other.complete_);
       hole_space_ = std::move(other.hole_space_);
       particle_space_ = std::move(other.particle_space_);
       return *this;
     }
   
     IndexSpaceRegistry clone() const;
   
     const auto& spaces() const { return spaces_; }
   
     decltype(auto) begin() const { return spaces_->cbegin(); }
     decltype(auto) end() const { return spaces_->cend(); }
   
     template <basic_string_convertible S>
     const IndexSpace* retrieve_ptr(S&& label) const {
       auto it =
           spaces_->find(IndexSpace::reduce_key(to_basic_string_view(label)));
       return it != spaces_->end() ? &(*it) : nullptr;
     }
   
     template <basic_string_convertible S>
     IndexSpace* retrieve_ptr(S&& label) {
       auto it =
           spaces_->find(IndexSpace::reduce_key(to_basic_string_view(label)));
       return it != spaces_->end() ? &(*it) : nullptr;
     }
   
     template <basic_string_convertible S>
     const IndexSpace& retrieve(S&& label) const {
       if (const auto* ptr = retrieve_ptr(std::forward<S>(label))) {
         return *ptr;
       } else
         throw IndexSpace::bad_key(label);
     }
   
     const IndexSpace* retrieve_ptr(const IndexSpace::Type& type,
                                    const IndexSpace::QuantumNumbers& qns) const {
       auto it = std::find_if(
           spaces_->begin(), spaces_->end(),
           [&](const auto& is) { return is.type() == type && is.qns() == qns; });
       return it != spaces_->end() ? &(*it) : nullptr;
     }
   
     const IndexSpace& retrieve(const IndexSpace::Type& type,
                                const IndexSpace::QuantumNumbers& qns) const {
       if (const auto* ptr = retrieve_ptr(type, qns)) {
         return *ptr;
       } else
         throw Exception(
             "IndexSpaceRegistry::retrieve(type,qn): missing { IndexSpace::Type=" +
             to_string(type) + " , IndexSpace::QuantumNumbers=" + to_string(qns) +
             " } combination");
     }
   
     const IndexSpace* retrieve_ptr(const IndexSpace::Attr& space_attr) const {
       auto it = std::find_if(
           spaces_->begin(), spaces_->end(),
           [&space_attr](const IndexSpace& s) { return s.attr() == space_attr; });
       return it != spaces_->end() ? &(*it) : nullptr;
     }
   
     const IndexSpace& retrieve(const IndexSpace::Attr& space_attr) const {
       if (const auto* ptr = retrieve_ptr(space_attr)) {
         return *ptr;
       } else
         throw Exception(std::string("IndexSpaceRegistry::retrieve(attr): attr=") +
                         to_string(space_attr) + " is missing");
     }
   
     template <basic_string_convertible S>
     bool contains(S&& label) const {
       return this->retrieve_ptr(std::forward<S>(label));
     }
   
     bool contains(const IndexSpace& space) const {
       return this->retrieve_ptr(space.type(), space.qns());
     }
   
     bool contains(const IndexSpace::Type& type,
                   const IndexSpace::QuantumNumbers& qns) const {
       return this->retrieve_ptr(type, qns);
     }
   
     bool contains(const IndexSpace::Attr& space_attr) const {
       return this->retrieve_ptr(space_attr);
     }
   
   
     IndexSpaceRegistry& add(const IndexSpace& IS) {
       auto it = spaces_->find(IS.base_key());
       if (it != spaces_->end()) {
         throw Exception(
             (std::string("IndexSpaceRegistry::add(index_space): space with "
                          "index_space.base_key()=") +
              toUtf8(IS.base_key()) +
              " already in the registry; if you are trying to replace the "
              "IndexSpace use "
              "IndexSpaceRegistry::replace(is)"));
       } else {
         // make sure there are no duplicate IndexSpaces whose attribute is
         // IS.attr()
         if (ranges::any_of(*spaces_,
                            [&IS](auto&& is) { return IS.attr() == is.attr(); })) {
           throw Exception(
               (std::string("IndexSpaceRegistry::add(index_space): space with "
                            "index_space.attr()=") +
                to_string(IS.attr()) +
                " already in the registry; if you are trying to replace the "
                "IndexSpace use "
                "IndexSpaceRegistry::replace(is)"));
         }
         spaces_->emplace(IS);
       }
   
       return clear_memoized_data_and_return_this();
     }
   
     template <basic_string_convertible S, typename... OptionalArgs>
     IndexSpaceRegistry& add(S&& type_label, IndexSpace::Type type,
                             OptionalArgs&&... args) {
       auto h_args = boost::hana::make_tuple(args...);
   
       // process IndexSpace::QuantumNumbers, set to default if not given
       auto h_qns = boost::hana::filter(h_args, [](auto arg) {
         return boost::hana::type_c<decltype(arg)> ==
                boost::hana::type_c<IndexSpace::QuantumNumbers>;
       });
       constexpr auto nqns = boost::hana::size(h_qns);
       static_assert(
           nqns == boost::hana::size_c<0> || nqns == boost::hana::size_c<1>,
           "IndexSpaceRegistry::add: only one IndexSpace::QuantumNumbers argument "
           "is allowed");
       constexpr auto have_qns = nqns == boost::hana::size_c<1>;
       IndexSpace::QuantumNumbers qns;
       if constexpr (have_qns) {
         qns = boost::hana::at_c<0>(h_qns);
       }
   
       // process approximate_size, set to default is not given
       auto h_ints = boost::hana::filter(h_args, [](auto arg) {
         return boost::hana::traits::is_integral(boost::hana::decltype_(arg));
       });
       constexpr auto nints = boost::hana::size(h_ints);
       static_assert(
           nints == boost::hana::size_c<0> || nints == boost::hana::size_c<1>,
           "IndexSpaceRegistry::add: only one integral argument is allowed");
       constexpr auto have_approximate_size = nints == boost::hana::size_c<1>;
       unsigned long approximate_size = 10;
       if constexpr (have_approximate_size) {
         approximate_size = boost::hana::at_c<0>(h_ints);
       }
   
       // make space
       IndexSpace space(std::forward<S>(type_label), type, qns, approximate_size);
       this->add(space);
   
       // process attribute tags
       auto h_attributes = boost::hana::filter(h_args, [](auto arg) {
         return !boost::hana::traits::is_integral(
                    boost::hana::type_c<decltype(arg)>) &&
                boost::hana::type_c<decltype(arg)> !=
                    boost::hana::type_c<IndexSpace::QuantumNumbers>;
       });
       process_attribute_tags(h_attributes, type);
   
       return clear_memoized_data_and_return_this();
     }
   
     template <basic_string_convertible S, index_space_or_label IndexSpaceOrLabel,
               typename... OptionalArgs>
     IndexSpaceRegistry& add_unIon(
         S&& type_label, std::initializer_list<IndexSpaceOrLabel> components,
         OptionalArgs&&... args) {
       SEQUANT_ASSERT(components.size() > 1);
   
       auto h_args = boost::hana::make_tuple(args...);
   
       // make space
       IndexSpace::Attr space_attr;
       long count = 0;
       if (components.size() <= 1) {
         throw Exception(
             "IndexSpaceRegistry::add_unIon: must have at least two components");
       }
       for (auto&& component : components) {
         const IndexSpace* component_ptr;
         if constexpr (std::is_same_v<std::decay_t<IndexSpaceOrLabel>,
                                      IndexSpace>) {
           component_ptr = &component;
         } else {
           component_ptr = &(this->retrieve(component));
         }
         if (count == 0)
           space_attr = component_ptr->attr();
         else
           space_attr = space_attr.unIon(component_ptr->attr());
         ++count;
       }
       const auto approximate_size = compute_approximate_size(space_attr);
   
       IndexSpace space(std::forward<S>(type_label), space_attr.type(),
                        space_attr.qns(), approximate_size);
       this->add(space);
       auto type = space.type();
   
       // process attribute tags
       auto h_attributes = boost::hana::filter(h_args, [](auto arg) {
         return !boost::hana::traits::is_integral(
                    boost::hana::type_c<decltype(arg)>) &&
                boost::hana::type_c<decltype(arg)> !=
                    boost::hana::type_c<IndexSpace::QuantumNumbers>;
       });
       process_attribute_tags(h_attributes, type);
   
       return clear_memoized_data_and_return_this();
     }
   
     template <basic_string_convertible S, index_space_or_label IndexSpaceOrLabel,
               typename... OptionalArgs>
     IndexSpaceRegistry& add_union(
         S&& type_label, std::initializer_list<IndexSpaceOrLabel> components,
         OptionalArgs&&... args) {
       return this->add_unIon(std::forward<S>(type_label), components,
                              std::forward<OptionalArgs>(args)...);
     }
   
     template <basic_string_convertible S, index_space_or_label IndexSpaceOrLabel,
               typename... OptionalArgs>
     IndexSpaceRegistry& add_intersection(
         S&& type_label, std::initializer_list<IndexSpaceOrLabel> components,
         OptionalArgs&&... args) {
       SEQUANT_ASSERT(components.size() > 1);
   
       auto h_args = boost::hana::make_tuple(args...);
   
       // make space
       IndexSpace::Attr space_attr;
       long count = 0;
       if (components.size() <= 1) {
         throw Exception(
             "IndexSpaceRegistry::add_intersection: must have at least two "
             "components");
       }
       for (auto&& component : components) {
         const IndexSpace* component_ptr;
         if constexpr (std::is_same_v<std::decay_t<IndexSpaceOrLabel>,
                                      IndexSpace>) {
           component_ptr = &component;
         } else {
           component_ptr = &(this->retrieve(component));
         }
         if (count == 0)
           space_attr = component_ptr->attr();
         else
           space_attr = space_attr.intersection(component_ptr->attr());
         ++count;
       }
       const auto approximate_size = compute_approximate_size(space_attr);
   
       IndexSpace space(std::forward<S>(type_label), space_attr.type(),
                        space_attr.qns(), approximate_size);
       this->add(space);
       auto type = space.type();
   
       // process attribute tags
       auto h_attributes = boost::hana::filter(h_args, [](auto arg) {
         return !boost::hana::traits::is_integral(
                    boost::hana::type_c<decltype(arg)>) &&
                boost::hana::type_c<decltype(arg)> !=
                    boost::hana::type_c<IndexSpace::QuantumNumbers>;
       });
       process_attribute_tags(h_attributes, type);
   
       return clear_memoized_data_and_return_this();
     }
   
   
     IndexSpaceRegistry& remove(const IndexSpace& IS) {
       auto it = spaces_->find(IS.base_key());
       if (it != spaces_->end()) {
         spaces_->erase(IS);
       }
       return clear_memoized_data_and_return_this();
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& remove(S&& label) {
       auto&& IS = this->retrieve(std::forward<S>(label));
       return this->remove(IS);
     }
   
     IndexSpaceRegistry& replace(const IndexSpace& IS) {
       this->remove(IS);
       return this->add(IS);
     }
   
     IndexSpaceRegistry& clear() {
       *this = IndexSpaceRegistry{};
       return *this;
     }
   
     bool valid_intersection(const IndexSpace& space1,
                             const IndexSpace& space2) const {
       auto result_attr = space1.attr().intersection(space2.attr());
       return result_attr != IndexSpace::Type::null && retrieve_ptr(result_attr);
     }
   
     template <basic_string_convertible S1, basic_string_convertible S2>
     bool valid_intersection(S1&& space1_key, S2&& space2_key) const {
       if (!contains(space1_key))
         throw Exception(
             std::string("IndexSpaceRegistry::valid_intersection(s1,s2): space "
                         "with key s1=") +
             toUtf8(space1_key) + " must be added to the registry first");
       if (!contains(space2_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::valid_intersection(s1,s2): space key s2=") +
             toUtf8(space2_key) + " must be added to the registry first");
       return this->valid_intersection(
           *(this->retrieve_ptr(std::forward<S1>(space1_key))),
           *(this->retrieve_ptr(std::forward<S2>(space2_key))));
     }
   
     const IndexSpace& intersection(const IndexSpace& space1,
                                    const IndexSpace& space2) const {
       if (space1 == space2) {
         return space1;
       } else {
         const auto target_qns = space1.qns().intersection(space2.qns());
         bool same_qns = space1.qns() == space2.qns();
         if (!target_qns && !same_qns) {  // spaces with different quantum numbers
                                          // do not intersect.
           return IndexSpace::null;
         }
   
         // check the registry
         auto intersection_type = space1.type().intersection(space2.type());
         const IndexSpace& intersection_space =
             find_by_attr({intersection_type, space1.qns()});
         // the nullspace is a reasonable return value for intersection
         if (intersection_space == IndexSpace::null && intersection_type) {
           throw Exception(
               std::string("intersection(s1=") + to_string(space1) +
               ",s2=" + to_string(space2) +
               ": no space with resulting type=" + to_string(intersection_type) +
               " is found in the registry. Add a "
               "space with this type to the registry.");
         } else {
           return intersection_space;
         }
       }
     }
   
     template <basic_string_convertible S1, basic_string_convertible S2>
     const IndexSpace& intersection(S1&& space1_key, S2&& space2_key) const {
       if (!contains(space1_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::intersection(s1,s2): space with key s1=") +
             toUtf8(space1_key) + " must be added to the registry first");
       if (!contains(space2_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::intersection(s1,s2): space key s2=") +
             toUtf8(space2_key) + " must be added to the registry first");
       return this->intersection(
           *(this->retrieve_ptr(std::forward<S1>(space1_key))),
           *(this->retrieve_ptr(std::forward<S2>(space2_key))));
     }
   
     bool valid_unIon(const IndexSpace& space1, const IndexSpace& space2) const {
       // check typeattr
       if (!space1.type().includes(space2.type()) &&
           space1.qns() == space2.qns()) {
         // union possible
         auto union_type = space1.type().unIon(space2.type());
         IndexSpace::Attr union_attr{union_type, space1.qns()};
         if (!find_by_attr(union_attr)) {  // possible but not registered
           return false;
         } else
           return true;
       }
       // check qn
       else if (!space1.qns().includes(space2.qns()) &&
                space1.type() == space2.type()) {
         // union possible
         auto union_qn = space1.qns().unIon(space2.qns());
         IndexSpace::Attr union_attr{space1.type(), union_qn};
         if (!find_by_attr(union_attr)) {  // possible but not registered
           return false;
         } else
           return true;
       } else {  // union not mathematically allowed.
         return false;
       }
     }
   
     template <basic_string_convertible S1, basic_string_convertible S2>
     bool valid_unIon(S1&& space1_key, S2&& space2_key) const {
       if (!contains(space1_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::valid_unIon(s1,s2): space with key s1=") +
             toUtf8(space1_key) + " must be added to the registry first");
       if (!contains(space2_key))
         throw Exception(
             std::string("IndexSpaceRegistry::valid_unIon(s1,s2): space key s2=") +
             toUtf8(space2_key) + " must be added to the registry first");
       return this->valid_unIon(
           *(this->retrieve_ptr(std::forward<S1>(space1_key))),
           *(this->retrieve_ptr(std::forward<S2>(space2_key))));
     }
   
     template <index_space_or_label T1, index_space_or_label T2>
     bool valid_union(T1&& t1, T2&& t2) const {
       return valid_unIon(std::forward<T1>(t1), std::forward<T2>(t2));
     }
   
     const IndexSpace& unIon(const IndexSpace& space1,
                             const IndexSpace& space2) const {
       if (!contains(space1))
         throw Exception(
             std::string("IndexSpaceRegistry::valid_unIon(s1,s2): space s1=") +
             to_string(space1) + " must be added to the registry first");
       if (!contains(space2))
         throw Exception(
             std::string("IndexSpaceRegistry::valid_unIon(s1,s2): space s2=") +
             to_string(space2) + " must be added to the registry first");
   
       if (space1 == space2) {
         return space1;
       } else {
         bool same_qns = space1.qns() == space2.qns();
         if (!same_qns) {
           throw Exception(
               std::string("IndexSpaceRegistry::valid_unIon(s1,s2): spaces s1=") +
               to_string(space1) + " and s2=" + to_string(space2) +
               " must have identical "
               "quantum number attributes.");
         }
         auto unIontype = space1.type().unIon(space2.type());
         const IndexSpace& unIonSpace = find_by_attr({unIontype, space1.qns()});
         if (unIonSpace == IndexSpace::null) {
           throw Exception(
               std::string("IndexSpaceRegistry::valid_unIon(s1,s2), s1=") +
               to_string(space1) + " and s2=" + to_string(space2) +
               ": the result is not registered, must register first.");
         } else {
           return unIonSpace;
         }
       }
     }
   
     template <basic_string_convertible S1, basic_string_convertible S2>
     const IndexSpace& unIon(S1&& space1_key, S2&& space2_key) const {
       if (!contains(space1_key))
         throw Exception(
             std::string("IndexSpaceRegistry::unIon(s1,s2): space with key s1=") +
             toUtf8(space1_key) + " must be added to the registry first");
       if (!contains(space2_key))
         throw Exception(
             std::string("IndexSpaceRegistry::unIon(s1,s2): space key s2=") +
             toUtf8(space2_key) + " must be added to the registry first");
       return this->unIon(*(this->retrieve_ptr(std::forward<S1>(space1_key))),
                          *(this->retrieve_ptr(std::forward<S2>(space2_key))));
     }
   
   
   
     void physical_particle_attribute_mask(bitset_t m);
   
   
     template <convertible_to_bitset T>
     void physical_particle_attribute_mask(T m) {
       this->physical_particle_attribute_mask(to_bitset(m));
     }
   
   
     bitset_t physical_particle_attribute_mask() const;
   
     IndexSpace::QuantumNumbers physical_particle_attributes(
         IndexSpace::QuantumNumbers qn) const;
   
     IndexSpace::QuantumNumbers other_attributes(
         IndexSpace::QuantumNumbers qn) const;
   
   
     const std::vector<IndexSpace::Type>& base_space_types() const {
       if (!base_space_types_) {
         auto types = *spaces_ | ranges::views::transform([](const auto& s) {
           return s.type();
         }) | ranges::views::filter([](const auto& t) { return is_base(t); }) |
                      ranges::views::unique | ranges::to_vector;
         ranges::sort(types, [](auto t1, auto t2) { return t1 < t2; });
         std::scoped_lock guard{mtx_memoized_};
         if (!base_space_types_) {
           base_space_types_ =
               std::make_shared<std::vector<IndexSpace::Type>>(std::move(types));
         }
       }
       return *base_space_types_;
     }
   
   
     const std::vector<IndexSpace>& base_spaces() const {
       if (!base_spaces_) {
         auto spaces = *spaces_ | ranges::views::filter([this](const auto& s) {
           return this->is_base(s);
         }) | ranges::views::unique |
                       ranges::to_vector;
         ranges::sort(spaces,
                      [](auto s1, auto s2) { return s1.type() < s2.type(); });
         std::scoped_lock guard{mtx_memoized_};
         if (!base_spaces_) {
           base_spaces_ =
               std::make_shared<std::vector<IndexSpace>>(std::move(spaces));
         }
       }
       return *base_spaces_;
     }
   
     bool is_base(const IndexSpace& IS) const {
       // is base if has base type and has no bits outsize of the physical particle
       // attribute mask
       return is_base(IS.type()) && !other_attributes(IS.qns());
     }
   
     template <basic_string_convertible S>
     bool is_base(S&& space_key) const {
       if (!contains(space_key))
         throw Exception(
             std::string("IndexSpaceRegistry::is_base(s): space with key s=") +
             toUtf8(space_key) + " must be added to the registry first");
       return this->is_base(*(this->retrieve_ptr(std::forward<S>(space_key))));
     }
   
     static bool is_base(const IndexSpace::Type& t) {
       return has_single_bit(t.to_int32());
     }
   
   
     bool is_pure_occupied(const IndexSpace& IS) const {
       if (!IS) {
         return false;
       }
       // this introduces icky dependence on bit footprint of vacuum_occupied_space
       if (IS.type().to_int32() <=
           vacuum_occupied_space(IS.qns()).type().to_int32()) {
         return true;
       } else {
         return false;
       }
     }
   
     template <basic_string_convertible S>
     bool is_pure_occupied(S&& space_key) const {
       if (!contains(space_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::is_pure_occupied(s): space with key s=") +
             toUtf8(space_key) + " must be added to the registry first");
       return this->is_pure_occupied(
           *(this->retrieve_ptr(std::forward<S>(space_key))));
     }
   
     bool is_pure_unoccupied(const IndexSpace& IS) const {
       if (!IS) {
         return false;
       } else {
         // Q: would be better to express as IS is a subspace of
         // vacuum_unoccupied_space? Then subspaces that are part of neither (this
         // is not supposed to happen) will not cause an issue here
         return !IS.type().intersection(
             vacuum_occupied_space(physical_particle_attributes(IS.qns())).type());
       }
     }
   
     template <basic_string_convertible S>
     bool is_pure_unoccupied(S&& space_key) const {
       if (!contains(space_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::is_pure_unoccupied(s): space with key s=") +
             toUtf8(space_key) + " must be added to the registry first");
       return this->is_pure_unoccupied(
           *(this->retrieve_ptr(std::forward<S>(space_key))));
     }
   
     bool contains_occupied(const IndexSpace& IS) const {
       return IS.type().intersection(vacuum_occupied_space(IS.qns()).type()) !=
              IndexSpace::Type::null;
     }
   
     template <basic_string_convertible S>
     bool contains_occupied(S&& space_key) const {
       if (!contains(space_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::contains_occupied(s): space with key s=") +
             toUtf8(space_key) + " must be added to the registry first");
       return this->contains_occupied(
           *(this->retrieve_ptr(std::forward<S>(space_key))));
     }
   
     bool contains_unoccupied(const IndexSpace& IS) const {
       return IS.type().intersection(vacuum_unoccupied_space(IS.qns()).type()) !=
              IndexSpace::Type::null;
     }
   
     template <basic_string_convertible S>
     bool contains_unoccupied(S&& space_key) const {
       if (!contains(space_key))
         throw Exception(
             std::string(
                 "IndexSpaceRegistry::contains_unoccupied(s): space with key s=") +
             toUtf8(space_key) + " must be added to the registry first");
       return this->contains_unoccupied(
           *(this->retrieve_ptr(std::forward<S>(space_key))));
     }
   
   
     IndexSpaceRegistry& vacuum_occupied_space(IndexSpace::Type t) {
       throw_if_missing(t, "vacuum_occupied_space");
       std::get<0>(vacocc_) = t;
       return *this;
     }
   
     IndexSpaceRegistry& vacuum_occupied_space(
         container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type) {
       throw_if_missing_any(qn2type, "vacuum_occupied_space");
       std::get<1>(vacocc_) = std::move(qn2type);
       return *this;
     }
   
     IndexSpaceRegistry& vacuum_occupied_space(const IndexSpace& s) {
       return vacuum_occupied_space(s.type());
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& vacuum_occupied_space(S&& l) {
       return vacuum_occupied_space(this->retrieve(std::forward<S>(l)).type());
     }
   
     const IndexSpace::Type& vacuum_occupied_space(
         bool nulltype_ok = false) const {
       if (!std::get<0>(vacocc_)) {
         if (nulltype_ok) return IndexSpace::Type::null;
         throw Exception(
             "vacuum occupied space has not been specified, invoke "
             "vacuum_occupied_space(IndexSpace::Type) or "
             "vacuum_occupied_space(container::map<IndexSpace::QuantumNumbers,"
             "IndexSpace::Type>)");
       } else
         return std::get<0>(vacocc_);
     }
   
     const IndexSpace& vacuum_occupied_space(IndexSpace::QuantumNumbers qn) const {
       auto it = std::get<1>(vacocc_).find(qn);
       if (it != std::get<1>(vacocc_).end()) {
         return retrieve(it->second, qn);
       } else {
         return retrieve(this->vacuum_occupied_space(), qn);
       }
     }
   
   
   
     IndexSpaceRegistry& reference_occupied_space(IndexSpace::Type t) {
       throw_if_missing(t, "reference_occupied_space");
       std::get<0>(refocc_) = t;
       return *this;
     }
   
     IndexSpaceRegistry& reference_occupied_space(
         container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type) {
       throw_if_missing_any(qn2type, "reference_occupied_space");
       std::get<1>(refocc_) = std::move(qn2type);
       return *this;
     }
   
     IndexSpaceRegistry& reference_occupied_space(const IndexSpace& s) {
       return reference_occupied_space(s.type());
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& reference_occupied_space(S&& l) {
       return reference_occupied_space(this->retrieve(std::forward<S>(l)).type());
     }
   
     const IndexSpace::Type& reference_occupied_space(
         bool nulltype_ok = false) const {
       if (!std::get<0>(refocc_)) {
         if (nulltype_ok) return IndexSpace::Type::null;
         throw Exception(
             "reference occupied space has not been specified, invoke "
             "reference_occupied_space(IndexSpace::Type) or "
             "reference_occupied_space(container::map<IndexSpace::QuantumNumbers,"
             "IndexSpace::Type>)");
       } else
         return std::get<0>(refocc_);
     }
   
     const IndexSpace& reference_occupied_space(
         IndexSpace::QuantumNumbers qn) const {
       auto it = std::get<1>(refocc_).find(qn);
       if (it != std::get<1>(refocc_).end()) {
         return retrieve(it->second, qn);
       } else {
         return retrieve(this->reference_occupied_space(), qn);
       }
     }
   
   
   
     IndexSpaceRegistry& complete_space(IndexSpace::Type s) {
       throw_if_missing(s, "complete_space");
       std::get<0>(complete_) = s;
       return *this;
     }
   
     IndexSpaceRegistry& complete_space(
         container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type) {
       throw_if_missing_any(qn2type, "complete_space");
       std::get<1>(complete_) = std::move(qn2type);
       return *this;
     }
   
     IndexSpaceRegistry& complete_space(const IndexSpace& s) {
       return complete_space(s.type());
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& complete_space(S&& l) {
       return complete_space(this->retrieve(std::forward<S>(l)).type());
     }
   
     const IndexSpace::Type& complete_space(bool nulltype_ok = false) const {
       if (!std::get<0>(complete_)) {
         if (nulltype_ok) return IndexSpace::Type::null;
         throw Exception(
             "complete space has not been specified, call "
             "complete_space(IndexSpace::Type)");
       } else
         return std::get<0>(complete_);
     }
   
     const IndexSpace& complete_space(IndexSpace::QuantumNumbers qn) const {
       auto it = std::get<1>(complete_).find(qn);
       if (it != std::get<1>(complete_).end()) {
         return retrieve(it->second, qn);
       } else {
         return retrieve(this->complete_space(), qn);
       }
     }
   
   
     const IndexSpace& vacuum_unoccupied_space(
         IndexSpace::QuantumNumbers qn) const {
       auto complete_type = this->complete_space(qn).type();
       auto vacocc_type = this->vacuum_occupied_space(qn).type();
       auto vacuocc_type =
           complete_type.xOr(vacocc_type).intersection(complete_type);
       return this->retrieve(vacuocc_type, qn);
     }
   
   
     IndexSpaceRegistry& hole_space(IndexSpace::Type t) {
       throw_if_missing(t, "hole_space");
       std::get<0>(hole_space_) = t;
       return *this;
     }
   
     IndexSpaceRegistry& hole_space(
         container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type) {
       throw_if_missing_any(qn2type, "hole_space");
       std::get<1>(hole_space_) = std::move(qn2type);
       return *this;
     }
   
     IndexSpaceRegistry& hole_space(const IndexSpace& s) {
       return hole_space(s.type());
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& hole_space(S&& l) {
       return hole_space(this->retrieve(std::forward<S>(l)).type());
     }
   
     const IndexSpace::Type& hole_space(bool nulltype_ok = false) const {
       if (!std::get<0>(hole_space_)) {
         if (nulltype_ok) return IndexSpace::Type::null;
         throw Exception(
             "active hole space has not been specified, invoke "
             "hole_space(IndexSpace::Type) or "
             "hole_space(container::map<IndexSpace::QuantumNumbers,IndexSpace::"
             "Type>)");
       } else
         return std::get<0>(hole_space_);
     }
   
     const IndexSpace& hole_space(IndexSpace::QuantumNumbers qn) const {
       auto it = std::get<1>(hole_space_).find(qn);
       if (it != std::get<1>(hole_space_).end()) {
         return this->retrieve(it->second, qn);
       } else {
         return this->retrieve(this->hole_space(), qn);
       }
     }
   
   
   
     IndexSpaceRegistry& particle_space(IndexSpace::Type t) {
       throw_if_missing(t, "particle_space");
       std::get<0>(particle_space_) = t;
       return *this;
     }
   
     IndexSpaceRegistry& particle_space(
         container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type) {
       throw_if_missing_any(qn2type, "particle_space");
       std::get<1>(particle_space_) = std::move(qn2type);
       return *this;
     }
   
     IndexSpaceRegistry& particle_space(const IndexSpace& s) {
       return particle_space(s.type());
     }
   
     template <basic_string_convertible S>
     IndexSpaceRegistry& particle_space(S&& l) {
       return particle_space(this->retrieve(std::forward<S>(l)).type());
     }
   
     const IndexSpace::Type& particle_space(bool nulltype_ok = false) const {
       if (!std::get<0>(particle_space_)) {
         if (nulltype_ok) return IndexSpace::Type::null;
         throw Exception(
             "active particle space has not been specified, invoke "
             "particle_space(IndexSpace::Type) or "
             "particle_space(container::map<IndexSpace::QuantumNumbers,"
             "IndexSpace::Type>)");
       } else
         return std::get<0>(particle_space_);
     }
   
     const IndexSpace& particle_space(IndexSpace::QuantumNumbers qn) const {
       auto it = std::get<1>(particle_space_).find(qn);
       if (it != std::get<1>(particle_space_).end()) {
         return this->retrieve(it->second, qn);
       } else {
         return this->retrieve(this->particle_space(), qn);
       }
     }
   
   
    private:
     // N.B. need transparent comparator, see https://stackoverflow.com/a/35525806
     std::shared_ptr<container::set<IndexSpace, IndexSpace::KeyCompare>> spaces_;
   
     bitset_t physical_particle_attribute_mask_ = bitset::null;
   
     // memoized data
     mutable std::shared_ptr<std::vector<IndexSpace::Type>> base_space_types_;
     mutable std::shared_ptr<std::vector<IndexSpace>> base_spaces_;
     mutable std::recursive_mutex
         mtx_memoized_;  // used to update the memoized data
     IndexSpaceRegistry& clear_memoized_data_and_return_this() {
       std::scoped_lock guard{mtx_memoized_};
       base_space_types_.reset();
       base_spaces_.reset();
       return *this;
     }
   
     static bool has_single_bit(std::uint32_t bits) {
       return bits && !(bits & (bits - 1));
     }
   
     const IndexSpace& find_by_attr(const IndexSpace::Attr& attr) const {
       for (auto&& space : *spaces_) {
         if (space.attr() == attr) {
           return space;
         }
       }
       return IndexSpace::null;
     }
   
     void throw_if_missing(const IndexSpace::Type& t,
                           const IndexSpace::QuantumNumbers& qn,
                           std::string call_context = "") {
       for (auto&& space : *spaces_) {
         if (space.type() == t && space.qns() == qn) {
           return;
         }
       }
       throw Exception(
           call_context + ": missing { IndexSpace::Type=" + to_string(t) +
           " , IndexSpace::QuantumNumbers=" + to_string(qn) + " } combination");
     }
   
     // same as above, but ignoring qn
     void throw_if_missing(const IndexSpace::Type& t,
                           std::string call_context = "") {
       for (auto&& space : *spaces_) {
         if (space.type() == t) {
           return;
         }
       }
       throw Exception(call_context + ": missing { IndexSpace::Type=" +
                       to_string(t) + " , any IndexSpace::QuantumNumbers } space");
     }
   
     void throw_if_missing_any(const container::map<IndexSpace::QuantumNumbers,
                                                    IndexSpace::Type>& qn2type,
                               std::string call_context = "") {
       container::map<IndexSpace::QuantumNumbers, IndexSpace::Type> qn2type_found;
       for (auto&& space : *spaces_) {
         for (auto&& [qn, t] : qn2type) {
           if (space.type() == t && space.qns() == qn) {
             [[maybe_unused]] auto [it, found] = qn2type_found.try_emplace(qn, t);
             SEQUANT_ASSERT(!found);
             // found all? return
             if (qn2type_found.size() == qn2type.size()) {
               return;
             }
           }
         }
       }
   
       std::string errmsg;
       for (auto&& [qn, t] : qn2type) {
         if (!qn2type_found.contains(qn)) {
           errmsg +=
               call_context +
               ": missing { IndexSpace::Type=" + std::to_string(t.to_int32()) +
               " , IndexSpace::QuantumNumbers=" + std::to_string(qn.to_int32()) +
               " } combination\n";
         }
       }
       throw Exception(errmsg);
     }
   
     // Need to define defaults for various traits, like which spaces are occupied
     // in vacuum, etc. Makes sense to make these part of the registry to avoid
     // having to pass these around in every call N.B. default and QN-specific
     // space selections merged into single tuple
   
     // used for fermi vacuum wick application
     std::tuple<IndexSpace::Type,
                container::map<IndexSpace::QuantumNumbers, IndexSpace::Type>>
         vacocc_ = {{}, {}};
   
     // used for MR MBPT to take average over multiconfiguration reference
     std::tuple<IndexSpace::Type,
                container::map<IndexSpace::QuantumNumbers, IndexSpace::Type>>
         refocc_ = {{}, {}};
   
     // defines active bits in TypeAttr; used by general operators in mbpt/op
     std::tuple<IndexSpace::Type,
                container::map<IndexSpace::QuantumNumbers, IndexSpace::Type>>
         complete_ = {{}, {}};
   
     // both needed to make excitation and de-excitation operators. not
     // necessarily equivalent in the case of multi-reference context.
     std::tuple<IndexSpace::Type,
                container::map<IndexSpace::QuantumNumbers, IndexSpace::Type>>
         hole_space_ = {{}, {}};
     std::tuple<IndexSpace::Type,
                container::map<IndexSpace::QuantumNumbers, IndexSpace::Type>>
         particle_space_ = {{}, {}};
   
     // Boost.Hana snippet to process attribute tag arguments
     template <typename ArgsHanaTuple>
     void process_attribute_tags(ArgsHanaTuple h_tuple,
                                 const IndexSpace::Type& type) {
       boost::hana::for_each(h_tuple, [this, &type](auto arg) {
         if constexpr (boost::hana::type_c<decltype(arg)> ==
                       boost::hana::type_c<space_tags::IsVacuumOccupied>) {
           this->vacuum_occupied_space(type);
         } else if constexpr (boost::hana::type_c<decltype(arg)> ==
                              boost::hana::type_c<
                                  space_tags::IsReferenceOccupied>) {
           this->reference_occupied_space(type);
         } else if constexpr (boost::hana::type_c<decltype(arg)> ==
                              boost::hana::type_c<space_tags::IsComplete>) {
           this->complete_space(type);
         } else if constexpr (boost::hana::type_c<decltype(arg)> ==
                              boost::hana::type_c<space_tags::IsHole>) {
           this->hole_space(type);
         } else if constexpr (boost::hana::type_c<decltype(arg)> ==
                              boost::hana::type_c<space_tags::IsParticle>) {
           this->particle_space(type);
         } else {
           static_assert(meta::always_false<decltype(arg)>::value,
                         "IndexSpaceRegistry::add{,_union,_intersect}: unknown "
                         "attribute tag");
         }
       });
     }
   
   
     unsigned long compute_approximate_size(
         const IndexSpace::Attr& space_attr) const {
       if (is_base(space_attr.type())) {
         return this->retrieve(space_attr).approximate_size();
       } else {
         // compute_approximate_size is used when populating the registry
         // so don't use base_spaces() here
         unsigned long size = ranges::accumulate(
             *spaces_ | ranges::views::filter([this, &space_attr](auto& s) {
               return s.qns() == space_attr.qns() && this->is_base(s.type()) &&
                      space_attr.type().intersection(s.type());
             }),
             0ul, [](unsigned long size, const IndexSpace& s) {
               return size + s.approximate_size();
             });
         return size;
       }
     }
   
     friend bool operator==(const IndexSpaceRegistry& isr1,
                            const IndexSpaceRegistry& isr2) {
       return *isr1.spaces_ == *isr2.spaces_;
     }
   };  // class IndexSpaceRegistry
   
   }  // namespace sequant
   #endif  // SEQUANT_INDEX_SPACE_REGISTRY_HPP

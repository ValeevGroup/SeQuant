
.. _program_listing_file_SeQuant_core_expressions_product.hpp:

Program Listing for File product.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_core_expressions_product.hpp>` (``SeQuant/core/expressions/product.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef SEQUANT_EXPRESSIONS_PRODUCT_HPP
   #define SEQUANT_EXPRESSIONS_PRODUCT_HPP
   
   #include <SeQuant/core/container.hpp>
   #include <SeQuant/core/expressions/constant.hpp>
   #include <SeQuant/core/expressions/expr.hpp>
   #include <SeQuant/core/expressions/expr_algorithms.hpp>
   #include <SeQuant/core/expressions/expr_ptr.hpp>
   #include <SeQuant/core/meta.hpp>
   #include <SeQuant/core/utility/macros.hpp>
   
   #include <string>
   #include <type_traits>
   
   namespace sequant {
   
   class Product : public Expr {
    public:
     enum class Flatten { Once, Recursively, Yes = Recursively, No };
   
     using scalar_type = Constant::scalar_type;
   
     Product() = default;
     virtual ~Product() = default;
     Product(const Product &) = default;
     Product(Product &&) = default;
     Product &operator=(const Product &) = default;
     Product &operator=(Product &&) = default;
   
     Product(ExprPtrList factors, Flatten flatten_tag = Flatten::Yes) {
       using std::begin;
       using std::end;
       for (auto it = begin(factors); it != end(factors); ++it)
         append(1, *it, flatten_tag);
     }
   
     template <typename Range>
       requires(meta::is_range_v<std::remove_cvref_t<Range>> &&
                !meta::is_same_v<std::remove_cvref_t<Range>, ExprPtrList>)
     explicit Product(Range &&rng, Flatten flatten_tag = Flatten::Yes) {
       // N.B. use append to flatten out Sum summands
       constexpr auto rng_is_expr =
           meta::is_base_of_v<Expr, std::remove_cvref_t<Range>>;
       constexpr auto rng_is_exprptr =
           meta::is_same_v<ExprPtr, std::remove_cvref_t<Range>>;
       if constexpr (rng_is_expr || rng_is_exprptr) {
         ExprPtr rng_as_exprptr;
         if constexpr (rng_is_expr) {
           rng_as_exprptr = rng.exprptr_from_this();
         } else {
           rng_as_exprptr = rng;
         }
         if (rng_as_exprptr.is<Product>()) {
           const auto &rng_as_product = rng_as_exprptr.as<Product>();
           for (const auto &v : rng_as_product.factors_)
             this->append(1, v, flatten_tag);
           this->scalar_ *= rng_as_product.scalar_;
         } else
           this->append(rng_as_exprptr);
       } else {
         for (auto &&v : rng) append(1, std::forward<decltype(v)>(v), flatten_tag);
       }
     }
   
     template <typename T, typename Range>
       requires(meta::is_range_v<std::remove_cvref_t<Range>> &&
                !meta::is_same_v<std::remove_cvref_t<Range>, ExprPtrList>)
     explicit Product(T scalar, Range &&rng, Flatten flatten_tag = Flatten::Yes)
         : Product(std::forward<Range>(rng), flatten_tag) {
       scalar_ *= std::move(scalar);
     }
   
     template <typename T>
     Product(T scalar, ExprPtrList factors, Flatten flatten_tag = Flatten::Yes)
         : scalar_(std::move(scalar)) {
       using std::begin;
       using std::end;
       for (auto it = begin(factors); it != end(factors); ++it)
         append(1, *it, flatten_tag);
     }
   
     template <typename Iterator>
     Product(Iterator begin, Iterator end, Flatten flatten_tag = Flatten::Yes) {
       for (auto it = begin; it != end; ++it) append(1, *it, flatten_tag);
     }
   
     template <typename T, typename Iterator>
     Product(T scalar, Iterator begin, Iterator end,
             Flatten flatten_tag = Flatten::Yes)
         : scalar_(std::move(scalar)) {
       for (auto it = begin; it != end; ++it) append(1, *it, flatten_tag);
     }
   
     template <typename T>
     Product &scale(T scalar) {
       scalar_ *= scalar;
       return *this;
     }
   
     template <typename T>
     Product &append(T scalar, ExprPtr factor,
                     Flatten flatten_tag = Flatten::Yes) {
       SEQUANT_ASSERT(factor);
       scalar_ *= scalar;
       if (!factor->is<Product>()) {
         if (factor->is<Constant>()) {  // factor in Constant
           auto factor_constant = factor->as<Constant>();
           scalar_ *= factor_constant.value();
           // no need to reset the hash since scalar is not hashed!
         } else {
           factors_.push_back(factor->clone());
           reset_hash_value();
         }
       } else {                             // factor is a product also ..
         if (flatten_tag != Flatten::No) {  // flatten, once or recursively
           const auto &factor_product = factor->as<Product>();
           scalar_ *= factor_product.scalar_;
           for (auto &&subfactor : factor_product)
             this->append(1, subfactor,
                          flatten_tag == Flatten::Once ? Flatten::No
                                                       : Flatten::Recursively);
         } else {
           factors_.push_back(factor->clone());
           reset_hash_value();
         }
       }
       return *this;
     }
   
     template <typename T, typename Factor,
               typename = std::enable_if_t<is_an_expr_v<Factor>>>
     Product &append(T scalar, Factor &&factor,
                     Flatten flatten_tag = Flatten::Yes) {
       return this->append(scalar,
                           std::static_pointer_cast<Expr>(
                               std::forward<Factor>(factor).shared_from_this()),
                           flatten_tag);
     }
   
     Product &append(ExprPtr factor, Flatten flatten_tag = Flatten::Yes) {
       return this->append(1, factor, flatten_tag);
     }
   
     template <typename Factor, typename = std::enable_if_t<is_an_expr_v<Factor>>>
     Product &append(Factor &&factor, Flatten flatten_tag = Flatten::Yes) {
       return this->append(std::static_pointer_cast<Expr>(
                               std::forward<Factor>(factor).shared_from_this()),
                           flatten_tag);
     }
   
     template <typename T>
     Product &prepend(T scalar, ExprPtr factor,
                      Flatten flatten_tag = Flatten::Yes) {
       SEQUANT_ASSERT(factor);
       scalar_ *= scalar;
       if (!factor->is<Product>()) {
         if (factor->is<Constant>()) {  // factor in Constant
           auto factor_constant = std::static_pointer_cast<Constant>(factor);
           scalar_ *= factor_constant->value();
           // no need to reset the hash since scalar is not hashed!
         } else {
           factors_.insert(factors_.begin(), factor->clone());
           reset_hash_value();
         }
       } else {  // factor is a product also  ... flatten recursively
         const auto &factor_product = factor->as<Product>();
         scalar_ *= factor_product.scalar_;
         if (flatten_tag != Flatten::No) {  // flatten, once or recursively
           for (auto &&subfactor : factor_product)
             this->prepend(1, subfactor,
                           flatten_tag == Flatten::Once ? Flatten::No
                                                        : Flatten::Recursively);
         } else {
           factors_.insert(factors_.begin(), factor->clone());
           reset_hash_value();
         }
       }
       return *this;
     }
   
     template <typename T, typename Factor,
               typename = std::enable_if_t<is_an_expr_v<Factor>>>
     Product &prepend(T scalar, Factor &&factor,
                      Flatten flatten_tag = Flatten::Yes) {
       return this->prepend(scalar,
                            std::static_pointer_cast<Expr>(
                                std::forward<Factor>(factor).shared_from_this()),
                            flatten_tag);
     }
   
     const auto &scalar() const { return scalar_; }
   
     bool is_zero() const { return Constant::is_zero(this->scalar()); }
   
     const auto &factors() const { return factors_; }
     auto &factors() { return factors_; }
   
     const ExprPtr &factor(size_t i) const { return factors_.at(i); }
   
     bool empty() const { return factors_.empty(); }
   
     virtual bool is_commutative() const;
   
     virtual void adjoint() override;
   
    private:
     virtual bool static_commutativity() const { return false; }
   
    public:
     std::wstring to_latex() const override { return to_latex(false); }
   
     std::wstring to_latex(bool negate) const {
       std::wstring result;
       result = L"{";
       if (!scalar().is_zero()) {
         const auto scal = negate ? -scalar() : scalar();
         if (!scal.is_identity()) {
           // replace -1 prefactor by -
           if (!(negate ? scalar() : -scalar()).is_identity()) {
             result += sequant::to_latex(scal);
           } else {
             result += L"{-}";
           }
         }
         for (const auto &i : factors()) {
           if (i->is<Product>())
             result += L"\\bigl(" + i->to_latex() + L"\\bigr)";
           else
             result += i->to_latex();
         }
       }
       result += L"}";
       return result;
     }
   
     std::wstring to_wolfram() const override {
       std::wstring result =
           is_commutative() ? L"Times[" : L"NonCommutativeMultiply[";
       if (scalar() != decltype(scalar_)(1)) {
         result += sequant::to_wolfram(scalar()) + L",";
       }
       const auto nfactors = factors().size();
       size_t factor_count = 1;
       for (const auto &i : factors()) {
         result += i->to_wolfram() + (factor_count == nfactors ? L"" : L",");
         ++factor_count;
       }
       result += L"]";
       return result;
     }
   
     type_id_type type_id() const override { return get_type_id<Product>(); };
   
     ExprPtr clone() const override { return ex<Product>(this->deep_copy()); }
   
     Product deep_copy() const {
       auto cloned_factors =
           factors() | ranges::views::transform([](const ExprPtr &ptr) {
             return ptr ? ptr->clone() : nullptr;
           });
       Product result(this->scalar(), ExprPtrList{});
       ranges::for_each(cloned_factors, [&](const auto &cloned_factor) {
         result.append(1, std::move(cloned_factor), Flatten::No);
       });
       return result;
     }
   
     virtual Expr &operator*=(const Expr &that) override {
       if (!that.is<Constant>()) {
         this->append(1, const_cast<Expr &>(that).shared_from_this());
       } else {
         scalar_ *= that.as<Constant>().value();
       }
       return *this;
     }
   
     void add_identical(const Product &other) {
       SEQUANT_ASSERT(ranges::equal(this->factors(), other.factors()));
       scalar_ += other.scalar_;
     }
   
     void add_identical(const std::shared_ptr<Product> &other) {
       SEQUANT_ASSERT(ranges::equal(this->factors(), other->factors()));
       scalar_ += other->scalar_;
     }
   
     void add_identical(const ExprPtr &other) {
       if (other.is<Product>()) return this->add_identical(other.as<Product>());
   
       // only makes sense if this has a single factor
       SEQUANT_ASSERT(this->factors_.size() == 1 && this->factors_[0] == other);
       scalar_ += 1;
     }
   
    private:
     scalar_type scalar_ = {1, 0};
     container::svector<ExprPtr, 2> factors_{};
   
     cursor begin_cursor() override {
       if (factors_.empty()) {
         return Expr::begin_cursor();
       } else {
         reset_hash_value();
         return cursor{&factors_[0]};
       }
     };
     cursor end_cursor() override {
       if (factors_.empty()) {
         return Expr::begin_cursor();
       } else {
         reset_hash_value();
         return cursor{&factors_[0] + factors_.size()};
       }
     };
   
     cursor begin_cursor() const override {
       return factors_.empty() ? Expr::begin_cursor() : cursor{&factors_[0]};
     };
     cursor end_cursor() const override {
       return factors_.empty() ? Expr::end_cursor()
                               : cursor{&factors_[0] + factors_.size()};
     };
   
     hash_type memoizing_hash() const override {
       auto compute_hash = [this]() {
         if (factors().size() == 1)
           return factors_[0]->hash_value();
         else {
           auto deref_factors =
               factors() |
               ranges::views::transform(
                   [](const ExprPtr &ptr) -> const Expr & { return *ptr; });
           auto value = hash::range(ranges::begin(deref_factors),
                                    ranges::end(deref_factors));
           return value;
         }
       };
   
       if (!hash_value_) {
         hash_value_ = compute_hash();
       } else {
         SEQUANT_ASSERT(*hash_value_ == compute_hash());
       }
   
       return *hash_value_;
     }
   
     ExprPtr canonicalize_impl(CanonicalizeOptions);
     virtual ExprPtr canonicalize(
         CanonicalizeOptions opt =
             CanonicalizeOptions::default_options()) override;
     virtual ExprPtr rapid_canonicalize(
         CanonicalizeOptions opts =
             CanonicalizeOptions::default_options().copy_and_set(
                 CanonicalizationMethod::Rapid)) override;
   
     bool static_equal(const Expr &that) const override {
       const auto &that_cast = static_cast<const Product &>(that);
       if (scalar() == that_cast.scalar() &&
           factors().size() == that_cast.factors().size()) {
         if (this->empty()) return true;
         // compare hash values first
         if (this->hash_value() ==
             that.hash_value())  // hash values agree -> do full comparison
           return std::equal(begin_subexpr(), end_subexpr(), that.begin_subexpr(),
                             expr_ptr_comparer);
         else
           return false;
       } else
         return false;
     }
   };  // class Product
   
   class CProduct : public Product {
    public:
     using Product::Product;
     CProduct(const Product &other) : Product(other) {}
     CProduct(Product &&other) : Product(other) {}
   
     bool is_commutative() const override { return true; }
   
     virtual void adjoint() override;
   
    private:
     bool static_commutativity() const override { return true; }
   };  // class CProduct
   
   class NCProduct : public Product {
    public:
     using Product::Product;
     NCProduct(const Product &other) : Product(other) {}
     NCProduct(Product &&other) : Product(other) {}
   
     bool is_commutative() const override { return false; }
   
     virtual void adjoint() override;
   
    private:
     bool static_commutativity() const override { return true; }
   };  // class NCProduct
   
   }  // namespace sequant
   
   #endif  // SEQUANT_EXPRESSIONS_PRODUCT_HPP


.. _program_listing_file_SeQuant_domain_mbpt_vac_av.hpp:

Program Listing for File vac_av.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_SeQuant_domain_mbpt_vac_av.hpp>` (``SeQuant/domain/mbpt/vac_av.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   //
   // Created by Eduard Valeyev on 2023-10-30.
   //
   
   #ifndef SEQUANT_DOMAIN_MBPT_VAC_AV_HPP
   #define SEQUANT_DOMAIN_MBPT_VAC_AV_HPP
   
   #include <SeQuant/domain/mbpt/op.hpp>
   
   namespace sequant::mbpt {
   inline namespace op {
   
   template <typename T>
   using OpConnections = std::vector<std::pair<T, T>>;
   
   inline OpConnections<std::wstring> default_op_connections() {
     static const OpConnections<std::wstring> defaults = {
         {L"h", L"t"},
         {L"f", L"t"},
         {L"f̃", L"t"},
         {L"g", L"t"},
         // NBs
         // - for unitary ansatz can also connect t^+ with Hamiltonian
         // - for exact (non-approximated) unitary ansatz will also need to connect
         // t^+ with t;
         //   for MR unitary ansatz can also connect t with t and t^+ with t^+ ,
         //   but since adjoint() does not change OpType all of these are expressed
         //   as same connection ... this points out the need to have a separate
         //   OpType for t^+ and t, and in general the contents of OpType must be
         //   customizable
         {L"t", L"h"},
         {L"t", L"f"},
         {L"t", L"f̃"},
         {L"t", L"g"}};
     return defaults;
   }
   
   inline OpConnections<std::wstring> concat(
       const OpConnections<std::wstring>& connections1,
       const OpConnections<std::wstring>& connections2) {
     return ranges::concat_view(connections1, connections2) | ranges::to_vector;
   }
   
   inline ExprPtr lower_to_tensor_form(ExprPtr& expr) {
     auto op_lowerer = [](ExprPtr& leaf) {
       if (leaf.is<op_t>()) leaf = leaf.as<op_t>().tensor_form();
     };
     expr->visit(op_lowerer, /* atoms only = */ true);
     return expr;
   }
   
   inline ExprPtr lower_to_tensor_form(const ExprPtr& expr_inp) {
     auto expr = expr_inp->clone();
     lower_to_tensor_form(expr);
     return expr;
   }
   
   ExprPtr expectation_value_impl(
       ExprPtr expr, const OpConnections<std::wstring>& op_connections,
       bool use_topology, bool screen, bool skip_clone, bool full_contractions);
   
   // clang-format off
   // clang_format on
   ExprPtr ref_av(ExprPtr expr, const OpConnections<std::wstring>& op_connections = default_op_connections(),
                  bool use_topology = true, bool screen = true,
                  bool skip_clone = false);
   
   ExprPtr vac_av(ExprPtr expr, const OpConnections<std::wstring>& op_connections = default_op_connections(),
                  bool use_topology = true, bool screen = true,
                  bool skip_clone = false);
   
   }  // namespace op
   }  // namespace sequant::mbpt
   #endif  // SEQUANT_DOMAIN_MBPT_VAC_AV_HPP

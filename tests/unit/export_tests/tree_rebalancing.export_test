( A{a1;i1} B{a2;a1} ) C{i1;a3}

=================================================
# Note that we are creating the expression tree
# 
#                    R
#                  /   \
#                 C     I
#                     /   \
#                    A     B
# which is suboptimal for evaluation as this requires (for a backend that
# can only deal with stack-like memory allocations) to have R, C, I, A
# and B in memory all at the same time. Thus, this tree has to be
# rearranged to
#                    R
#                  /   \
#                 I     C
#               /   \
#              A     B
# which allows to not have C in memory while computing I from A and B,
# even in with stack-like memory model.
# 
=================================================
=================================================
Plain Text
=================================================
Declare index i_1
Declare index a_1
Declare index a_2
Declare index a_3

Declare tensor A[a_1, i_1]
Declare tensor B[a_2, a_1]
Declare tensor C[i_1, a_3]
Declare tensor I[a_2, i_1]
Declare tensor I[a_2, a_3]

Create I[a_2, a_3] and initialize to zero
Create I[a_2, i_1] and initialize to zero
Load A[a_1, i_1]
Load B[a_2, a_1]
Compute I[a_2, i_1] += A[a_1, i_1] B[a_2, a_1]
Unload B[a_2, a_1]
Unload A[a_1, i_1]
Load C[i_1, a_3]
Compute I[a_2, a_3] += I[a_2, i_1] C[i_1, a_3]
Unload C[i_1, a_3]
Unload I[a_2, i_1]
Persist I[a_2, a_3]

=================================================

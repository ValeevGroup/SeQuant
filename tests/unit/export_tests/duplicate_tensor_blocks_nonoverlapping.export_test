(( A{a1;i2} B{i1;a1} ) E{i2;a3} ) ( C{a2;i4} D{i3;a2} )

=================================================
# Computation of A * B and C * D leads to an intermediate of the same
# shape/dimension. Since these two results are not needed
# simultaneously, we can allocate a single tensor for one and reuse it
# for the other (after having reset it to zero before)
=================================================
=================================================
Plain Text
=================================================
Declare index i_1
Declare index i_2
Declare index i_3
Declare index i_4
Declare index a_1
Declare index a_2
Declare index a_3

Declare tensor A[a_1, i_2]
Declare tensor B[i_1, a_1]
Declare tensor C[a_2, i_4]
Declare tensor D[i_3, a_2]
Declare tensor E[i_2, a_3]
Declare tensor I[i_1, i_2]
Declare tensor I[i_1, a_3]
Declare tensor I[i_1, i_3, i_4, a_3]

Create I[i_1, i_3, i_4, a_3] and initialize to zero
Create I[i_1, a_3] and initialize to zero
Create I[i_1, i_2] and initialize to zero
Load A[a_1, i_2]
Load B[i_1, a_1]
Compute I[i_1, i_2] += A[a_1, i_2] B[i_1, a_1]
Unload B[i_1, a_1]
Unload A[a_1, i_2]
Load E[i_2, a_3]
Compute I[i_1, a_3] += I[i_1, i_2] E[i_2, a_3]
Unload E[i_2, a_3]
Unload I[i_1, i_2]
Load I[i_3, i_4] and set it to zero
Load C[a_2, i_4]
Load D[i_3, a_2]
Compute I[i_3, i_4] += C[a_2, i_4] D[i_3, a_2]
Unload D[i_3, a_2]
Unload C[a_2, i_4]
Compute I[i_1, i_3, i_4, a_3] += I[i_1, a_3] I[i_3, i_4]
Unload I[i_3, i_4]
Unload I[i_1, a_3]
Persist I[i_1, i_3, i_4, a_3]

=================================================

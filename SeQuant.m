(* ::Package:: *)

BeginPackage["SeQuant`"];

(* turn on Assert *)
On[Assert];


(* Setting up internal things *)
Off[General::spell];
Off[General::spell1];
$RecursionLimit = 8192;
$IterationLimit = Infinity;
(*SetOptions[$FrontEnd,CommonDefaultFormatTypes->{"Output"->TraditionalForm}];*)
NCM = NonCommutativeMultiply;


(* ::Section::Closed:: *)
(* Global Parameters *)


(*
Special Operators
*)
Unprotect[defaultHamiltonianOpers];
Unprotect[ignoreDisconnectedOpers];
Unprotect[ignoreConnectedOpers];
defaultHamiltonianOpers = {"F","g","\!\(\*OverscriptBox[\(g\), \(_\)]\)"};
ignoreDisconnectedOpers = {};
ignoreConnectedOpers = {};
Protect[ignoreConnectedOpers];
Protect[ignoreDisconnectedOpers];
Protect[defaultHamiltonianOpers];


(*
Global SeQuant Parameters
*)
If[ !ValueQ[SeQuantDebugLevel],
    SeQuantDebugLevel = 0
];

SeQuantVacuumChoices["Physical"] = 0;
SeQuantVacuumChoices["SingleConfiguration"] = 1;
SeQuantVacuumChoices["MultiConfiguration"] = 2;

If[ !ValueQ[SeQuantVacuum],
    SeQuantVacuum = SeQuantVacuumChoices["SingleConfiguration"]
];


(* Definition of spaces *)
occ = particleSpace[occupied];
virt = particleSpace[virtual];
othervirt = particleSpace[othervirtual];
any = Union[occ,virt];
allvirt = Union[virt,othervirt];
allany = Union[occ,allvirt];


(* Definition of spaces with spin *)
occA = Append[occ,particleSpin[A]];
virtA=Append[virt,particleSpin[A]];
othervirtA=Append[othervirt,particleSpin[A]];
allvirtA=Append[allvirt,particleSpin[A]];
anyA = Append[any,particleSpin[A]];
allanyA = Append[allany,particleSpin[A]];
occB = Append[occ,particleSpin[B]];
virtB=Append[virt,particleSpin[B]];
othervirtB=Append[othervirt,particleSpin[B]];
allvirtB=Append[allvirt,particleSpin[B]];
anyB = Append[any,particleSpin[B]];
allanyB = Append[allany,particleSpin[B]];


spacesEqualIgnoreParticleType[a_particleSpace,b_particleSpace] :=
    (Select[a,Head[#]=!=particleType&]==Select[b,Head[#]=!=particleType&]); 
spacesOverlapIgnoreParticleType[a_particleSpace,b_particleSpace] :=
    (Select[Intersection[a,b],Head[#]=!=particleType&]=!=particleSpace[]);
spacesOverlapIgnoreSpinAndParticleType[a_particleSpace,b_particleSpace] :=
    (Select[Intersection[a,b],Head[#]=!=particleType&&Head[#]=!=particleSpin&]=!=particleSpace[]);
spacesOverlap[a_particleSpace,b_particleSpace] :=
    (spacesOverlapIgnoreSpinAndParticleType[a,b] && Select[a,Head[#]===particleType&]===Select[b,Head[#]===particleType&]&& Select[a,Head[#]===particleSpin&]===Select[b,Head[#]===particleSpin&]);
(* return +1 if above, -1 if below, 0 if neither or both *)
spaceWRTFermiLevel[a_particleSpace] :=
    If[ spacesOverlapIgnoreSpinAndParticleType[a,allvirt],
        If[ spacesOverlapIgnoreSpinAndParticleType[a,occ],
            0,
            +1
        ],
        If[ spacesOverlapIgnoreSpinAndParticleType[a,occ],
            -1,
            0
        ]
    ];


(* Global index for most recently generated index 
Generated indices are named iXX, where i is generated by DefaultSpaceSymbol *)
GlobalIndexCounter = 0;

DefaultSpaceSymbol[occ] = "i";
DefaultSpaceSymbol[virt] = "a";
DefaultSpaceSymbol[allvirt] = "\[Alpha]";
DefaultSpaceSymbol[othervirt] = "\[Alpha]'";
DefaultSpaceSymbol[any] = "p";
DefaultSpaceSymbol[allany] = "\[Kappa]";
DefaultSpaceSymbol[occA]="\!\(\*SubscriptBox[\(i\), \(\[Alpha]\)]\)";
DefaultSpaceSymbol[virtA]="\!\(\*SubscriptBox[\(a\), \(\[Alpha]\)]\)";
DefaultSpaceSymbol[allvirtA]="\!\(\*SubscriptBox[\(\[Alpha]\), \(\[Alpha]\)]\)";
DefaultSpaceSymbol[othervirtA]="\!\(\*SubsuperscriptBox[\(\[Alpha]\), \(\[Alpha]\), \(,\)]\)";
DefaultSpaceSymbol[anyA]="\!\(\*SubscriptBox[\(p\), \(\[Alpha]\)]\)";
DefaultSpaceSymbol[allanyA]="\!\(\*SubscriptBox[\(\[Kappa]\), \(\[Alpha]\)]\)";
DefaultSpaceSymbol[occB]="\!\(\*SubscriptBox[\(i\), \(\[Beta]\)]\)";
DefaultSpaceSymbol[virtB]="\!\(\*SubscriptBox[\(a\), \(\[Beta]\)]\)";
DefaultSpaceSymbol[allvirtB]="\!\(\*SubscriptBox[\(\[Alpha]\), \(\[Beta]\)]\)";
DefaultSpaceSymbol[othervirtB]="\!\(\*SubsuperscriptBox[\(\[Alpha]\), \(\[Beta]\), \(,\)]\)";
DefaultSpaceSymbol[anyB]="\!\(\*SubscriptBox[\(p\), \(\[Beta]\)]\)";
DefaultSpaceSymbol[allanyB]="\!\(\*SubscriptBox[\(\[Kappa]\), \(\[Beta]\)]\)";


(* ::Section::Closed:: *)
(* particleIndex Class *)


(* create particleIndex with space and symbol i *)
createParticleIndex[i_String,space_particleSpace] :=
    Module[ {},
        particleIndex[i,space]
    ];
    
(* create particleIndex with DefaultSpaceSymbol *)
createParticleIndex[space_particleSpace] :=
    createParticleIndex[ToString[Subscript[DefaultSpaceSymbol[space],
    GlobalIndexCounter++],TraditionalForm],space];
    
(* takes A and replaces name and space with i and s, respectively *)
createParticleIndex[A_particleIndex,i_String,s_particleSpace] :=
    Module[ {},
        If[ Length[A]==3,
            particleIndex[i,s,A[[3]]],
            particleIndex[i,s]
        ]
    ];
    
(* if a has particleIndex b ignoring indexType *)
indexQ[a_,b_particleIndex] :=
    MemberQ[a,c_particleIndex/;(c[[1]]==b[[1]])&&(c[[2]]==b[[2]]),Infinity];

(* if particleIndex a has indexType[cre]*)
indexCreQ[a_particleIndex] :=
    MemberQ[a,indexType[cre]];
    
(* if particleIndex a has indexType[ann]*)
indexAnnQ[a_particleIndex] :=
    MemberQ[a,indexType[ann]];

(* if particleIndex a has indexType[bra]*)
indexBraQ[a_particleIndex] :=
    MemberQ[a,indexType[bra]];

(* if particleIndex a has indexType[ket]*)
indexKetQ[a_particleIndex] :=
    MemberQ[a,indexType[ket]];
    
(* return indexType of particleIndex with indexType *)
indexType[a_particleIndex] :=
    Cases[a,_indexType][[1,1]]
    
(* return particleSpace of particleIndex *)
indexSpace[a_particleIndex] :=
    Cases[a,_particleSpace][[1]];
    
(* return the particleType of a particleIndex *)
indexParticle[a_particleIndex] :=
    Module[ {typeList},
        typeList = Cases[a[[2]],_particleType];
        If[ typeList=={},
            Return[particleType[default]],
            Return[typeList[[1]]]
        ]
    ];

(* return the symbol of particleIndex *)
indexSymbol[a_particleIndex] :=
    a[[1]];
    
(* remove indexType *)
indexLight[a_particleIndex] :=
    createParticleIndex[indexSymbol[a],indexSpace[a]];

(* if particleIndex equiv ignoring indexType *)
indexEquiv[a_particleIndex,b_particleIndex] :=
    (a[[1]]===b[[1]])&&(a[[2]]===b[[2]]);
    
Unprotect[Equal];
Equal[a_particleIndex,b_particleIndex] :=
    (a[[1]]===b[[1]])&&(a[[2]]===b[[2]]);
Protect[Equal];

(* canonical ordering of particleIndex objects is defined as follows: order by particleSpace first, then alphabetically by the symbol *)
Unprotect[OrderedQ];
OrderedQ[A_particleSpace,B_particleSpace] :=
    If[ OrderedQ[A[[2]],B[[2]]],
        OrderedQ[A[[1]],B[[1]]],
        True
    ];
Protect[OrderedQ];

(* this functions throws out all multiple occurences of the same index from inds *)
uniqueIndexList[inds_List] :=
    Module[ {tmpinds},

(* Old code *)
(*tmpinds={inds[[1]]};
Do[
ind=inds[[i]];
If[!indexQ[tmpinds,ind],
tmpinds=Append[tmpinds,ind]
],
{i,Length[inds]}
];*)

(* Union does it now *)
        tmpinds = Union[inds];
        Return[tmpinds];
    ];

(* "tag " and "untag " all indices in expr which also appear in intInds. uses indexQ *)
tagIndex[index_particleIndex] :=
    Append[index,mysecrettag[]];
tagIndex[expr_] :=
    expr;
untagIndex[index_particleIndex] :=
    DeleteCases[index,_mysecrettag];
untagIndex[expr_] :=
    expr;

tagIndices[expr_,inds_List] :=
    Module[ {result,ninds,pos,ind},
        ninds = Length[inds];
        result = expr;
        Do[
            ind = inds[[i]];
            pos = Position[result,c_particleIndex/;indexEquiv[c,ind]];
            result = MapAt[tagIndex,result,pos],{i,1,ninds}];
        Return[result];
    ];

untagIndices[expr_,inds_List] :=
    Module[ {result,ninds,pos,ind},
        ninds = Length[inds];
        result = expr;
        Do[
            ind = inds[[i]];
            pos = Position[result,c_particleIndex/;indexEquiv[c,ind]];
            result = MapAt[untagIndex,result,pos],{i,1,ninds}];
        Return[result];
    ];
    


(* ::Section::Closed:: *)
(* SQS Class *)


(*
SQS is a string of creation/annihilation operators
only normal ordered strings can be utilized at the moment
 *)
inorder = normalOrder[True];
noorder = normalOrder[False];
createSQS[creInds_List,annInds_List,norm_normalOrder:inorder] :=
    Module[ {},
    	If[ SeQuantVacuum === SeQuantVacuumChoices["MultiConfiguration"],
			Return[mSQS[norm, flattenSQS[SQS[creInds,annInds,norm]]]]
    	];
        Return[flattenSQS[SQS[creInds,annInds,norm]]]
    ];

createSQS[creInds_List, annInds_List ] := 
        Return[flattenSQS[SQS[creInds,annInds]]]

SQS::wrongdepth = "Argument has wrong depth";
flattenSQS[a_SQS] :=
    Module[ {nc,na,result,creInds,annInds,x},
        Off[Append::normal];
        If[ Depth[a]<5,
            Return[a]
        ];
        Clear[result];
        Clear[creInds];
        Clear[annInds];
        Clear[x];
        na = Length[a[[2]]];
        nc = Length[a[[1]]];
        creInds = Cases[a[[1]],x_particleIndex->Append[x,indexType[cre]]];
        annInds = Cases[a[[2]],x_particleIndex->Append[x,indexType[ann]]];
        result = FlattenAt[SQS[FlattenAt[{creInds,Reverse[annInds]},{{1},{2}}]],{1}];
        Return[result];
    ];


(* SQS in MultiConfiguration case has non normal ordered form *)    
(*
createmultiSQS[creInds_List,annInds_List,norm_normalOrder:inorder] :=
    Module[ {},
        Return[multiSQS[norm, createSQS[creInds,annInds,norm]]]
    ];
*)

(* find all index types in a *)
indexTypesSQS[a_SQS] :=
    Module[ {ninds,ind,types,type},
        ninds = Length[a];
        types = {};
        Do[
            type = indexParticle[a[[ind]]];
            types = Append[types,type]
            ,{ind,1,ninds}
        ];
        types = Union[Flatten[types]];
        Return[types];
    ];

(* find the number of ptype operator in a *)
numIndicesOfType[a_SQS,ptype_particleType] :=
    Module[ {ninds,result},
        ninds = Length[a];
        result = 0;
        Do[
        	result+=If[ indexParticle[a[[i]]]===ptype,
                       1,
                       0
                    ]
           ,{i,1,ninds}
        ];
        Return[result];
    ];

(*Find the first index of ptype, else return -1*)
firstIndexOfType[a_SQS,ptype_particleType] :=
    Module[ {ninds,ind,index},
        ninds = Length[a];
        ind = -1;
        Do[
            index = a[[i]];
            If[ indexParticle[index]===ptype,
                ind = i;
                Break[]
            ]
           ,{i,1,ninds}
        ];
        Return[ind];
    ];

(* selects creation/annihilation indices from SQS 
	while the indexType was droped
*)
creIndices[a_SQS] :=
    Cases[a,x_particleIndex/;indexCreQ[x]->indexLight[x] ];
annIndices[a_SQS] :=
    Reverse[Cases[a,x_particleIndex/;indexAnnQ[x]->indexLight[x] ]];


(* ::Section::Closed:: *)
(*  SQM class  *)


(*
SQM is a matrix element of an operator
operators can be classified as antisymm, symm, and nonsymmetric, which will help in reducing expressions to their simplest form
 *)
antisymm = indexSymm[-1];
symm = indexSymm[1];
nonsymm = indexSymm[0];
createSQM[O_String,braInds_List,ketInds_List,symm_indexSymm:antisymm] :=
    Module[ {},
        Return[flattenSQM[SQM[O,braInds,ketInds,symm]]]
    ];
SQM::wrongdepth = "Argument has wrong depth";
flattenSQM[a_SQM] :=
    Module[ {nb,nk,result,braInds,ketInds,x},
        Off[Append::normal];
        If[ Depth[a]<5,
            Return[a]
        ];
        Clear[result];
        Clear[braInds];
        Clear[ketInds];
        Clear[x];
        nb = Length[a[[2]]];
        nk = Length[a[[3]]];
        braInds = Cases[a[[2]],x_particleIndex->Append[x,indexType[bra] ] ];
        ketInds = Cases[a[[3]],x_particleIndex->Append[x,indexType[ket] ] ];
        result = FlattenAt[SQM[FlattenAt[{braInds,ketInds},{{1},{2}}]],{1}];
        result = Prepend[result,OHead[a[[1]],a[[4]]]];
        Return[result];
    ];
    
    
(* selects bra/ket indices from SQM 
	while the indexType was droped
*)
braIndices[a_SQM] :=
	Cases[a,x_particleIndex/;indexBraQ[x]->indexLight[x] ];
    
ketIndices[a_SQM] :=
	Cases[a,x_particleIndex/;indexKetQ[x]->indexLight[x] ];

(*
the following two functions are used to deal with \Eta SQM in MultiConfigution
*)

(* expand \eta to \lamda and \delta *)
expandEta[a_SQM] := 
	Module[{bra, ket, result},
   		bra = braIndices[a];
   		ket = ketIndices[a];
   		result = Plus[deltaIndex[bra[[1]], ket[[1]]], -createSQM["\[Lambda]", bra, ket, antisymm] ];
		Return[result];
   ];

(* expand every \eta in expr *)
expandExp[expr_] :=
	expr /. x_SQM /; x[[1, 1]] == "\[Eta]" -> expandEta[x]


(* convert cumulant to density matricies *)
(* this function is not universal,
	it only works for rank 1 and 2 cumulant
*)
convertLambda[a_SQM] :=
	Module[{bra, ket, result},
		bra = braIndices[a];
		ket = ketIndices[a];
		Assert[ Length[bra] === Length[ket] ];
		If [ Length[bra] === 1,	 
			result = createSQM["\[Gamma]",bra,ket,antisymm];
			Return[result]
		];

		If [Length[bra] === 2,
			If [Depth[a] === 4,
				result = createSQM["\[Gamma]",bra,ket,antisymm] - createSQM["\[Gamma]",{bra[[1]]},{ket[[1]]},antisymm]*createSQM["\[Gamma]",{bra[[2]]},{ket[[2]]},antisymm] 
					+ createSQM["\[Gamma]",{bra[[1]]},{ket[[2]]},antisymm]*createSQM["\[Gamma]",{bra[[2]]},{ket[[1]]},antisymm]; 
				Return[result]
			];
			(*in spin free case, the rank one density with different spin will be zero *)
			If [Depth[a] === 5,
				result = createSQM["\[Gamma]",bra,ket,antisymm] - spinConvertGamma[{bra[[1]]},{ket[[1]]}]*spinConvertGamma[{bra[[2]]},{ket[[2]]}] 
					+ spinConvertGamma[{bra[[1]]},{ket[[2]]}]*spinConvertGamma[{bra[[2]]},{ket[[1]]}]; 
				Return[result]
			];
		];
		If[ Length[bra] > 2 ,
			Return[a]
		];
	];
	
spinConvertGamma[bra_List, ket_List] := 
	Module[{tmpbra, tmpket, spinsame, result},
		spinsame = True;
		tmpbra = bra[[1]];
		tmpket = ket[[1]];
		If[ tmpbra[[2,-1]] =!= tmpket[[2,-1]],
			spinsame = False;
		];
		If [ spinsame,
			result = createSQM["\[Gamma]",bra,ket,antisymm],
			result = 0;
		];
		Return[result];
	];

convertExp[expr_] :=
	expr /. x_SQM /; x[[1,1]] == "\[Lambda]" -> convertLambda[x]



(* ::Section:: *)
(* Visualize function *)


(* these functions display particleIndex in string *)

visualizeIndex[a_particleIndex] :=
	a[[1]];

Format[particleIndex[a__],TraditionalForm] :=
    visualizeIndex[particleIndex[a]];
    
    
(* these functions display SQ expressions in tensor notation *)
visualizeSQE[a_*b_] :=
    visualizeSQE[a]*visualizeSQE[b];
visualizeSQE[a_**b_] :=
    visualizeSQE[a]**visualizeSQE[b];
visualizeSQE[a_^n_Integer] :=
    visualizeSQE[a]^n;
visualizeSQE[a_+b_] :=
    visualizeSQE[a]+visualizeSQE[b];
visualizeSQE[a_/;(Head[a]=!=SQS&&Head[a]=!=deltaIndex&&Head[a]=!=SQM&&Head[a]=!=mSQS)] :=
    a;
visualizeSQE[a_deltaIndex] :=
    Subsuperscript["\[Delta]",a[[1,1]],a[[2,1]] ];

visualizeSQE[a_SQS] :=
    Module[ {bodyLabel,i,supInds,subInds},
(* convention labels strings normal-ordered wrt to nonphysical vacuum as tilde{a} *)

        bodyLabel = If[SeQuantVacuum==SeQuantVacuumChoices["Physical"],"a","\[ATilde]"];
        supInds = "";
        subInds = "";
        Do[
            If[ Cases[a[[i]],_indexType][[1,1]]===cre,
                supInds = StringJoin[supInds,a[[i,1]] ],
                subInds = StringJoin[a[[i,1]],subInds ]
            ],{i,1,Length[a] }
        ];
        Return[Subsuperscript[bodyLabel,subInds,supInds]]
    ];

visualizeSQE[a_mSQS] :=
    Module[ {sqs,bodyLabel,i,supInds,subInds},
    	If [ Length[a[[2]]] === 0,
    		Return[a[[2]]]
    	];
        bodyLabel = If[ a[[1]] === normalOrder[True],
                        OverTilde["a"],
                        "a"
                    ];
        sqs = a[[2]];
        supInds = "";
        subInds = "";
        Do[
            If[ Cases[sqs[[i]],_indexType][[1,1]]===cre,
                supInds = StringJoin[supInds,sqs[[i,1]] ],
                subInds = StringJoin[sqs[[i,1]],subInds ]
            ],
            {i,1,Length[sqs] }
        ];
        Return[Subsuperscript[bodyLabel,subInds,supInds]]
    ];
    
visualizeSQE[a_SQM] :=
    Module[ {bodyLabel,i,supInds,subInds},
        bodyLabel = a[[1,1]];
        supInds = "";
        subInds = "";
        Do[
            If[ indexKetQ[a[[i]]],
                supInds = StringJoin[supInds,a[[i,1]] ],
                subInds = StringJoin[subInds,a[[i,1]] ]
            ],{i,2,Length[a] }
        ];
        Return[Subsuperscript[bodyLabel,subInds,supInds]]
    ];

Format[deltaIndex[a__],TraditionalForm] :=
    visualizeSQE[deltaIndex[a]];
Format[SQM[a__],TraditionalForm] :=
    visualizeSQE[SQM[a]];
Format[SQS[a__],TraditionalForm] :=
    visualizeSQE[SQS[a]];
Format[mSQS[a__],TraditionalForm] :=
    visualizeSQE[mSQS[a]];



(* ::Section:: *)
(* Contraction functions *)


(*
Low-level contraction routines

contractIndex contracts 2 indices
contractSQS contracts a List of SQ strings of operators

deltaIndex is our representation of Kroneker delta
*)
contractIndex[L_particleIndex,R_particleIndex] :=
    Module[ {typeL,typeR, fermiL, fermiR,intIndex,result},
    	(* check if particles are the same *)
        typeL = Cases[L[[2]],_particleType];
        typeR = Cases[R[[2]],_particleType];
        If[ typeL=!=typeR,
            Return[0]
        ];
        (*if both creation or both annihilation - result is 0*)
        If[ L[[3]]==R[[3]],
            Return[0]
        ];

        (* the case of a multiconfiguration vacuum cannot be handled by simple Wick-type rules *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["MultiConfiguration"],
            Print["Wick theorem for MultiConfiguration vacuum is not expressed as simple contraction"];
            Abort[]
        ];
        (* discard zero contractions for the case of a determinant vacuum *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["SingleConfiguration"],
            fermiL = spaceWRTFermiLevel[L[[2]]];
            If[ L[[3]]==indexType[ann]&&fermiL==-1,
                Return[0]
            ];
            If[ L[[3]]==indexType[cre]&&fermiL==+1,
                Return[0]
            ];
            fermiR = spaceWRTFermiLevel[R[[2]]];
            If[ R[[3]]==indexType[cre]&&fermiR==-1,
                Return[0]
            ];
            If[ R[[3]]==indexType[ann]&&fermiR==+1,
                Return[0]
            ];
        ];
        (* discard zero contractions for the case of a physical vacuum *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["Physical"],
            If[ L[[3]]==indexType[cre],
                Return[0]
            ];
        ];
        If[ !spacesOverlap[L[[2]],R[[2]]],
            Return[0]
        ];
        If[ SeQuantDebugLevel>=5,
            Print["In contractIndex: ",L//TraditionalForm," and ", R//TraditionalForm]
        ];
        (* single-configuration contractions involving general (non-particle and non-hole) indices involve particle and hole density matrices *)
        If[ SeQuantVacuum==SeQuantVacuumChoices["SingleConfiguration"]&&(fermiL==0&&fermiR==0),
            (* must be unoccupied *)
            If[ R[[3]]==indexType[cre],
                intIndex = createParticleIndex[allvirt];
                result = deltaIndex[Drop[L,{3}],intIndex ] *  deltaIndex[intIndex,Drop[R,{3}] ];
            ];
            (* must be occupied *)
            If[ R[[3]]==indexType[ann],
                intIndex = createParticleIndex[occ];
                result = deltaIndex[Drop[R,{3}],intIndex ] *  deltaIndex[intIndex,Drop[L,{3}] ];
            ];
            Return[result];
        ];
        If[ L[[1]]==R[[1]],
            Return[1]
        ];
        If[ R[[3]]===indexType[cre],
            Return[deltaIndex[Drop[L,{3}],Drop[R,{3}] ] ],
            Return[deltaIndex[Drop[R,{3}],Drop[L,{3}] ] ]
        ];
    ];


(* contractIndex function used in MultiConfiguration
	return True if it is nonzero contration
	return False if it is zero contraction
*)

contractIndex[a_List] := 
	Module[{bra, ket, spinmatch, tmpresult, result},
		If [ Depth[a] === 4,
			result = !MemberQ[a, y_particleIndex /; spaceWRTFermiLevel[indexSpace[y]] === +1];
			Return[result]
		];
		(* for spin free cases *)
		(* only rank one cumulant will be zero if the spin is different  *)
		If [ Depth[a] === 5,
			tmpresult = !MemberQ[a, y_particleIndex /; spaceWRTFermiLevel[indexSpace[y]] === +1];
			If[ !tmpresult,
				Return[tmpresult];
			];
			spinmatch = True;
			If[ Length[a] === 2,
				ket = a[[1]];
				bra = a[[2]];
				If [ bra[[2,-1]] =!= ket[[2,-1]],
					spinmatch = False;
				]
			];
			result = tmpresult && spinmatch;
			Return[result];
		];
	];
(* if a has member deltaIndex b *)
deltaQ[a_,b_deltaIndex] :=
    MemberQ[a,c_deltaIndex/;(indexQ[c,b[[1]] ]&&indexQ[c,b[[2]] ])];



(* ::Subsection:: *)
(* CR Class *)


(*
CR is the head for a general result of a contraction (unless it's a zero)
such a result consists of a prefactor and a noncommutative product of SQ strings:
CR[pfac,body]
*)
factorIntoCR[a_,0] :=
    0;
factorIntoCR[a_,b_CR] :=
    CR[a*b[[1]],b[[2]]];
factorIntoCR[a_,b:Plus[__]] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[b];
        Do[result+=factorIntoCR[a,b[[i]]],{i,1,nterms}];
        Return[result];
    ];
AddCR[a_CR,b_CR] :=
    CR[1,a+b];
    
(* returns c if it does not equal to t *)
uniqueCR[t_CR,c_CR] :=
    If[ t=!=c,
        c,
        0
    ];
    
(* returns members of c that do not equal to t *)
uniqueCR[t_CR,c_Plus] :=
    Module[ {uc},
        uc = 0;
        Do[uc+=uniqueCR[t,c[[i]]],
            {i,1,Length[c]}
        ];
        Return[uc];
    ];

(* returns c if it does not appear in t *)
uniqueCR[t_Plus,c_CR] :=
    If[ FreeQ[t,c],
        c,
        0
    ];

(* returns the terms in c that do not appear in t *)
uniqueCR[t_Plus,c_Plus] :=
    Module[ {uc},
        uc = 0;
        Do[uc+=uniqueCR[t,c[[i]]],
            {i,1,Length[c]}
        ];
        Return[uc];
    ];

(* return the number of CR in Plus *)
numberCR[t_Plus] := 
	Module[ {len, num},
		num = 0;
		len = Length[t];
		Do[
			If[ Head[t[[i]] ] === CR,
				num += 1
			];
			,{i,1,len}
		];
		Return[num]
	];
	
numberCR[t_CR] := 
	1;



(* ::Subsection:: *)
(*  Contract SQS  *)


(*

  If fullContract
    find the first index
    contract recursively, i.e. result = contraction[i,j]*contractSQS[str/ij]
  else
    loop over all pairs of indices i and j
       result += normalOrderedForm[str] + contraction[i,j]*contractSQS[str/ij]

*)

contractSQS[str:NCM[__SQS],ptype_particleType,contractOptions_List] :=
    Module[ {result,newcontractOptions,sqsL,sqsR,indexL,indexR,indL,indR,iR,indRoff,strLoff,contr1,contr2,newstr,sqsLlast,sqsLfirst,indLfirst,indLlast,newcontrib,f,nstr},
    	
        If[ Depth[str]==2,
            Return[CR[1,1]]
        ];
        
        If[ SeQuantDebugLevel>=5,
            Print["called contract SQS for str=",str//TraditionalForm," ptype=",ptype//TraditionalForm]
        ];

        (*Recursively drop empty strings*)
        result = {};
        Do[
        	sqsL = sL;
        	If[ Length[str[[sL]]]==0,
            	result = contractSQS[Drop[str,{sL}],ptype,contractOptions ];
            	Break[]
        	],
        	{sL,1,Length[str]}
        ];
        If[ result=!={},
            Return[result]
        ];

        (*Cannot contract single string*)
        If[ Length[str]==1,
        	If [ SeQuantVacuum==SeQuantVacuumChoices["MultiConfiguration"],
            	result = If[ !(finalfullContract/.contractOptions),
                         CR[1,str[[1]]],
                         0
                     	],
            	result = If[ !(fullContract/.contractOptions),
                         CR[1,str[[1]]],
                         0
                     	]
        	];
            Return[result]
        ];
        
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: dropped all empty strings str=",str//TraditionalForm]
        ];

    	nstr = Length[str];
    	If [ SeQuantVacuum==SeQuantVacuumChoices["MultiConfiguration"],
    		If [ nstr === 2,
				(* If the last contraction, do fullContraction if finalfullContraction is True  *)
				If [ finalfullContract/. contractOptions,
    				newcontractOptions = Cases[contractOptions, a_ /; FreeQ[a, fullContract]];
    				newcontractOptions = Append[ newcontractOptions, fullContract->True ],
    				newcontractOptions = Cases[contractOptions, a_ /; FreeQ[a, fullContract]];
    				newcontractOptions = Append[ newcontractOptions, fullContract->False ]
				];    			
    			result = contractSQS[str[[1]],str[[2]],newcontractOptions];
    			Return[result],
    			
    			
    			(* If not the last contraciton, do not do fullContraction *)
    			If [ fullContract/. contractOptions,
    				newcontractOptions = Cases[contractOptions, a_ /; FreeQ[a, fullContract]];
    				newcontractOptions = Append[ newcontractOptions, fullContract->False ],
    				newcontractOptions = contractOptions
				];    
    			result = contractSQS[str[[1]],str[[2]], newcontractOptions];
    			newstr = Take[ str, {3,nstr}];
    			f[a_CR] := (
    				If[ a[[2]] === 1,
    					CR[ a[[1]], newstr ],
    					CR[ a[[1]], a[[2]]**newstr ]	
    				]
    				);
    			(* when there is only one CR[] result, map function no longer works *)
				If [ numberCR[result] === 1,
					result = f[result],
    				result = Map[f, result]
				];

    			If[ SeQuantDebugLevel>=5,
    				Print["new contraction    ", result//TraditionalForm];
        		];
    			
    			result = contractSQS[result, ptype, newcontractOptions]
    		];
			Return[result];
    	];

        (*Find the first string that has an index of ptype*)
        indRoff = 0;
        sqsL = -1;
        Do[
        
        	indL = firstIndexOfType[str[[sL]],ptype];
        	If[ indL!=-1,
            	sqsL = sL;
            	Break[]
        	],
        
        	{sL,1,Length[str]-1}
        ];
        
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: first substring that contains index of ptype = ",sqsL]
        ];

        (*exit if such string is not found*)
        If[ sqsL==-1,
            result = If[ (fullContract/.contractOptions),
                         0,
                         CR[1,str]
                      ];
            Return[result]
        ];

        (* If not doing full contraction, then first add the strings reordered into normal order (taking into account the signs) *)
        If[ SeQuantDebugLevel>=7,
            Print["in contractSQS: ",(fullContract/.contractOptions)]
        ];
        
        result = If[ !(fullContract/.contractOptions),
                     normalOrderedForm[str,ptype],
                     0
                 ];

        (* Only one string needs to be considered if full contraction is sought *)
        sqsLfirst = sqsL;
        sqsLlast = If[ !(fullContract/.contractOptions),
                       Length[str]-1,
                       sqsL
                   ];
        Do[
        	sqsL = sL;
        	indL = firstIndexOfType[str[[sqsL]],ptype];
       		 If[ indL==-1,
            	Continue[]
        		];

        	(* only 1 index need to be considered if seeking a full contraction *)
        	indLfirst = indL;
        	indLlast = If[ !(fullContract/.contractOptions),
                       Length[str[[sqsL]]],
                       indL
                   	];

       	 	(* strLoff keeps track of the distance between the first ptype index in strL and the end of the string. It's used to initialize indRoff.
        	indRoff is the distance between left and right indices *)
        	strLoff = numIndicesOfType[str[[sqsL]],ptype];
        	Do[
        		indL = iL;
        		indexL = str[[sqsL,indL]];
        		If[ indexParticle[indexL]=!=ptype,
            		Continue[]
        		];
        		strLoff--;
        		indRoff = strLoff+1;
        		If[ SeQuantDebugLevel>=7,
            		Print["Chose left index: indexL = ",indexL//TraditionalForm," indRoff = ",indRoff];
        		];

        		(*Contract with every other index of ptype*)
        		Do[
        
       				 iR = 0;
        			Do[ 
        				indexR = str[[sqsR,indR]];
       					 If[ SeQuantDebugLevel>=7,
            				Print["Chose right index: indexL = ",indexL//TraditionalForm," indexR = ",indexR//TraditionalForm," indRoff = ",indRoff];
       					 ];
        				If[ indexParticle[indexR]=!=ptype,
           					 Continue[],
           					 iR+=1
       					 ];
       					 If[ SeQuantDebugLevel>=5,
            				Print["Calling contractIndex for ",indexL//TraditionalForm," and ", indexR//TraditionalForm]
        				 ];
        				contr1 = contractIndex[indexL,indexR];
        				If[ SeQuantDebugLevel>=5,
            				Print["result = ",contr1//TraditionalForm]
        				];
        				If[ contr1=!=0,
            				(newstr = Join[
            				Take[str,{1,sqsL-1}],NCM[Drop[str[[sqsL]],{indL}]],Take[str,{sqsL+1,sqsR-1}],NCM[Drop[str[[sqsR]],{indR}]],Take[str,{sqsR+1,Length[str]}]
            				];
             				If[ SeQuantDebugLevel>=5,
                				 Print["Prefactor: ",(-1)^(iR+indRoff-2)*contr1//TraditionalForm];
                				 Print["Dropped string: ",newstr//TraditionalForm];
                 				 Print["Contracting: ",sqsL," ",indL," ",sqsR," ",indR," iR=",iR," indRoff=",indRoff];
             				];
             				contr2 = contractSQS[newstr,ptype,contractOptions];
            				newcontrib = factorIntoCR[(-1)^(iR+indRoff-2)*contr1,contr2];
             				(* before adding to the result, need to canonizalize if seeking operator rather than full contraction
                			the same term can appear multiple times if fullContract is false, hence must detect such cases reliably
            				 *)
             				If[ !(fullContract/.contractOptions),
                 				newcontrib = Map[maporder,newcontrib,2];
                			 	If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): result (before accumulate) = ",result//TraditionalForm]
                 			 	];
                 			 	If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): newcontrib (before accumulate) = ",newcontrib//TraditionalForm]
                 			 	];
                 				result+=uniqueCR[result,newcontrib];
                 				If[ SeQuantDebugLevel>=5,
                     				Print["contractSQS(",str//TraditionalForm,"): result (after accumulate) = ",result//TraditionalForm]
                 				];,
                 				result+=newcontrib
             		     	];
             				If[ SeQuantDebugLevel>=5,
                 				Print["contractSQS(",str//TraditionalForm,"): Contracted result: ",contr2//TraditionalForm];
                 				Print["contractSQS(",str//TraditionalForm,"): Total result: ",result//TraditionalForm]
             				];
            				)
        				],
        				{indR,1,Length[str[[sqsR]]]}
        			];
       			 	indRoff+=numIndicesOfType[str[[sqsR]],ptype],
        
        			{sqsR,sL+1,Length[str]}
        		],
        
        		{iL,indLfirst,indLlast}
        	],
        
        	{sL,sqsLfirst,sqsLlast}
        ];
        Return[result];
    ];
    
contractSQS[NCM[],_particleType,_List] :=
    CR[1,1];
    
contractSQS[0,_particleType,_List] :=
    0;
    
(*contractSQS is distributive*)
contractSQS[str_Plus,ptype_particleType,contractOptions_List] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[str];
        Do[result+=contractSQS[str[[i]],ptype,contractOptions],{i,1,nterms}];
        If[ SeQuantDebugLevel>=2,
            Print["contractSQS (Plus): str = ",str//TraditionalForm," ptype = ", ptype," result = ",result//TraditionalForm]
        ];
        Return[result];
    ];
(*separate out prefactors before the contraction*)
(*contractSQS[(a_/;FreeQ[a,SQS])*b_,ptype_particleType,contractOptions_List]:=Module[{result},result=contractSQS[b,ptype,contractOptions];result=CR[a*result[[1]],result[[2]]];Return[result];];*)
contractSQS[str_CR,ptype_particleType,contractOptions_List] :=
    Module[ {result},
        result = contractSQS[str[[2]],ptype,contractOptions];
        result = factorIntoCR[str[[1]],result];
        Return[result];
    ];
    
(*contracting a single string is easy*)
contractSQS[a_SQS,ptype_particleType,contractOptions_List] :=
    If[ SeQuantVacuum == SeQuantVacuumChoices["MultiConfiguration"],
    	Print [ contractOptions ];
    	If[ (finalfullContract/.contractOptions),
        	0,
        	CR[1,a]
    	],
    	If[ (fullContract/.contractOptions),
        	0,
        	CR[1,a]
    	]
    ];


(*This is a top-level string contraction routine that applies contractions to each particle type*)
contractSQSNTypes[str:NCM[__SQS],contractOptions_List] :=
    Module[ {result,nstr,ind,ptypes,ntypes,intermedOptions},
    	
    	If[ SeQuantVacuum == SeQuantVacuumChoices["MultiConfiguration"],
    		intermedOptions = Cases[contractOptions, a_ /; MemberQ[a, fullContract]];
    		intermedOptions = Append [ intermedOptions, finalfullContract-> fullContract/. intermedOptions];
    		result = contractSQSNstr[str,intermedOptions];
    		Return[result];
    	];
    	
        nstr = Length[str];
        ptypes = {};
        
        Do[
        	ptypes = Append[ptypes,indexTypesSQS[str[[ind]]]],
        	{ind,1,nstr}
        ];
        ptypes = Union[Flatten[ptypes]];
        ntypes = Length[ptypes];

        (*All intermediate contractions are incomplete contractions*)
        intermedOptions = Cases[contractOptions,a_/;FreeQ[a,fullContract]];
        intermedOptions = Append[intermedOptions,fullContract->False];
        result = str;
        Do[
			GlobalIndexCounter = 0;
        	result = contractSQS[result,ptypes[[ind]],intermedOptions];
       		If[ SeQuantDebugLevel>=4,
            	Print["Result after ",ind," contractions is: ",result//TraditionalForm]
        		],
        	{ind,1,ntypes-1}
        ];

		GlobalIndexCounter = 0;
        (*The last contraction carried according to user's specs*)
        result = contractSQS[result,ptypes[[ntypes]],contractOptions];
        If[ SeQuantDebugLevel>=4,
            Print["Result after the final contraction is: ",result//TraditionalForm]
        ];
        (*Remove CR heads*)
        result = Replace[result,CR->Times,-1,Heads->True];
        If[ SeQuantDebugLevel>=4,
            Print["Normal-looking result after the final contraction is: ",result //TraditionalForm]
        ];
        Return[result];
    ];
    
contractSQSNTypes[{},_particleType,_List] :=
    1;

(* This is a top-level string contraction routine that applies contractions to MultiConfiguration *)
contractSQSNstr[str:NCM[___SQS], contractOptions_List] :=
	Module[ {result, ptype },
		ptype = particleType[default];
		result = contractSQS[str,ptype,contractOptions];
		(*Remove CR heads*)
        result = Replace[result,CR->Times,-1,Heads->True];
        Return[result];
	];


(* contraction function for MultiConfiguration *)

contractSQS[L_SQS, R_SQS, contractOptions_List] := 
	Module[ {l, r, ls, rs, lu, ll, ru, rl, ui, li, n, pt, lenp, contras, lencons, contra, original, sign, lencon, tmpi, tmpleni, cross, tmpcre, tmpann, tmpcontra, tmpop, tmpresult, ptmpresult, result },
    
    If[ SeQuantDebugLevel >= 5,
        Print [ "Contraction \n", L //TraditionalForm , R //TraditionalForm];
    ];
    If[ SeQuantDebugLevel >= 6,
    	Print [ "contraction type \n" , "fullContract   ->  ", fullContract/. contractOptions];
    ];
    
    (* left side SQS *)
    ls = L;
    (* right side SQS *)
    rs = R;
    (* left side upper indices *)
    lu = creIndices[ls];
    (* left side lowwer indices *)
    ll = annIndices[ls];
    l = Join[lu, ll];
    (* right side upper indices *)
    ru = creIndices[rs];
    (* right side lowwer indices *)
    rl = annIndices[rs];
    r = Join[ru, rl];
    (* upper indices *)
    ui = Join[lu, ru];
    (* lower indices *)
    li = Join[ll, rl];
    
    (* original sequence *)
    original = Join[ui, Reverse[li] ];
    n = Length[ui];
    Assert [ n === Length[li] ];
    pt = contractionPattern[n];
    lenp = Length[pt];
    
    (* create all possible contractin patterns *)
    contras = {};
    Do[
        contras = Join[ contras, uniquePattern[ui, li, pt[[i]]] ];
            ,{i,1,lenp}
        ];
    lencons = Length[contras];
    result = Plus[];
    
    (* loop over each contraction pattern *)
    Do [
        contra = contras[[i]];
        If[ SeQuantDebugLevel >= 6,
            Print [ " contraction pattern \n" , contra //TraditionalForm ]
        ];
        sign = signrule[original, contra];
        If[ SeQuantDebugLevel >= 7,
            Print [ " permutation of this pattern:    " , sign ]
        ];
        lencon = Length[contra];
        (* test if cross contraction *)
        cross = True;
        (* first include zero-rank contraciton and full-rank contraction *)
        If[ lencon === 1,
            cross = True,
            Do [
                tmpi = contra[[j]];
                If[ Length[ Intersection[l , contra[[j]]] ] === Length [ contra[[j]] ] || Length[ Intersection[r , contra[[j]]] ] === Length [ contra[[j]] ],
                    cross = False
                ];
                ,{j,1,lencon}
            ];
        ];
        (* loop over each combination and create contraction*)
            
        (* full contraction *)
        If[ cross === True,
            tmpresult = 1;
            Do [
                tmpleni = Length[contra[[j]] ]/2;
                tmpcre = Take[contra[[j]], tmpleni ];
                tmpann = Take[contra[[j]], - tmpleni];
                If[ contractIndex[ contra[[j]] ],
                    If[ Length[ contra[[j]] ]=== 2 && Length[ Intersection[ru, contra[[j]]] ] > 0 && Length[ Intersection[ll, contra[[j]]] ] > 0,
                        tmpcontra = (-1) * createSQM["\[Eta]",tmpann, tmpcre, nonsymm],
                        tmpcontra = createSQM["\[Lambda]",tmpann, tmpcre, antisymm]
                    ],
                    If[ Length[ contra[[j]] ]=== 2 && Length[ Intersection[ru, contra[[j]]] ] > 0 && Length[ Intersection[ll, contra[[j]]] ] > 0,
                        (* for spinfree, delta with different spin will become zero *)
                        If[ Depth[contra[[j]] ] === 5 && tmpann[[1]][[2,-1]] =!= tmpcre[[1]][[2,-1]],
                        	tmpcontra = 0,
                            tmpcontra =  (-1) * deltaIndex[tmpann[[1]], tmpcre[[1]]]
                        ],
                        tmpcontra = 0
                    ]
                ];
                
                If[ SeQuantDebugLevel >= 7,
                    Print [ "       result of contraction:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =  ", tmpcontra //TraditionalForm ]
                ];
                
                tmpresult = tmpresult * tmpcontra;
                ,{j,1,lencon}
            ];
            
            If[ tmpresult =!= 0,
                tmpresult = CR[ sign * tmpresult, 1]
            ];
            
            If[ SeQuantDebugLevel >= 6,
                Print[ " full contraction in this pattern:    ", tmpresult //TraditionalForm ]
            ];
            
            result = Plus[result, tmpresult],
            
            If[ SeQuantDebugLevel >= 6,
                Print[ " full contraction in this pattern:    ",  0 ]
            ];
        ];
        
        (* partial contraction *)
        If[ !fullContract/. contractOptions,
            tmpresult = Plus[];
            Do[
                tmpleni = Length[contra[[j]] ] /2;
                tmpcre = Take[contra[[j]], tmpleni ];
                tmpann = Take[contra[[j]], - tmpleni];
                tmpop = createSQS[tmpcre, tmpann];
                
                If[ SeQuantDebugLevel >= 7,
                    Print [ "       result of the operator:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =   ", tmpop //TraditionalForm ]
                ];
                
                cross = True;
                ptmpresult = 1;
                Do[
                    If[ k =!= j,
                        tmpleni = Length[contra[[k]] ]/2;
                        tmpcre = Take[contra[[k]], tmpleni ];
                        tmpann = Take[contra[[k]], - tmpleni];
                        
                        If[ Length[ Intersection[l , contra[[k]]] ] === Length [ contra[[k]] ] || Length[ Intersection[r , contra[[k]]] ] === Length [ contra[[k]] ],
                            cross = False
                        ];
                        
                        If[ cross === True,
                            If[ contractIndex[ contra[[k]] ],
                                If[ Length[ contra[[k]] ]=== 2 && Length[ Intersection[ru, contra[[k]]] ] > 0 && Length[ Intersection[ll, contra[[k]]] ] > 0,
                                    tmpcontra =  (-1) * createSQM["\[Eta]",tmpann, tmpcre, nonsymm],
                                    tmpcontra =  createSQM["\[Lambda]",tmpann, tmpcre, antisymm]
                                ],
                                If[ Length[ contra[[k]] ]=== 2 && Length[ Intersection[ru, contra[[k]]] ] > 0 && Length[ Intersection[ll, contra[[k]]] ] > 0,
                                	(* for spinfree, delta with different spin will become zero *)
                                	If[ Depth[contra[[k]] ] === 5 && tmpann[[1]][[2,-1]] =!= tmpcre[[1]][[2,-1]],
                                    	tmpcontra = 0,
                                    	tmpcontra =  (-1) * deltaIndex[tmpann[[1]], tmpcre[[1]]]
                                	],	
                                    	tmpcontra =  0
                                ]
                            ],
                            tmpcontra =  0
                        ];
                        
                        ptmpresult = ptmpresult * tmpcontra;
                        
                        If[ SeQuantDebugLevel >= 7,
                            Print [ "       result of contraction:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =  ", tmpcontra //TraditionalForm ]
                        ]
                    ];     
                	,{k,1,lencon}    
             	];
             	
                If[ ptmpresult =!= 0,
                    tmpresult = Plus[tmpresult, CR[sign*ptmpresult,tmpop]]
                ];
                ,{j,1,lencon}
            ];
            
            tmpresult = Plus[tmpresult];
            
            If[ SeQuantDebugLevel >= 6,
                Print[ " partial contraction in this pattern:    ", tmpresult //TraditionalForm ]
            ];
            result = Plus[result,  tmpresult]
        ];
        ,{i,1,lencons}
    ];
    
    If[ SeQuantDebugLevel >= 5,
        Print [ "contraction  result   ", result // TraditionalForm];
    ];
    
    Return[result];
];


(* functions for contraction pattern for MultiConfiguration *)


(* contraction number pattern in MultiConfiguration *)
contractionPattern[n_Integer] := 
			 IntegerPartitions[n]
			 
			 
(* function to create unique contraction pattern for MultiConfiguration *)
uniquePattern[cres_List, anns_List, pattern_List] := 
	Module[{lc,la, lp, sump, clist, alist,  tmpresult, result},
		lc = Length[cres];
		la = Length[anns];
		Assert[ lc === la ];
		lp = Length[pattern];
		sump = Total[pattern];
		Assert[ lc === sump ];
		If [ lp === 1,
			Return[List[List[Join[cres, anns]]] ]
		];
		clist = Permutations[cres];
		alist = Permutations[anns];
		tmpresult = combinePattern[clist, alist, pattern];
		result = DeleteDuplicates[tmpresult];
		Return[result];
	];

(* combine the pattern of creation indecies and annihilation indecies *) 
combinePattern[creslist_List, annslist_List, pattern_List] :=
	Module[{lc, la, lp, csub, asub, ctmp, atmp, rtmp, count, tmpresult, result},
		lc = Length[creslist];
		la = Length[annslist];
		Assert [ lc === la ];
		lp = Length[pattern];
		result = {};
		Do [
			csub = creslist[[i]];
			Do[
				asub = annslist[[j]];
				count = 1;
				tmpresult = {};
				Do [
					ctmp = Sort[Take[csub, {count, count-1 + pattern[[k]]} ]];
					atmp = Sort[Take[asub, {count, count-1 + pattern[[k]]} ]];
					rtmp = Join[ctmp, atmp];
					tmpresult = Append[tmpresult, rtmp];
					count += pattern[[k]];
					,{k,1,lp}
				];
				tmpresult = Sort[tmpresult];
				result = Append[result, tmpresult];
				,{j,1,la}
			];
			,{i,1,la}	
		];
		Return[result];
	];
	


(* ::Section:: *)
(* Normal Order *)


(*
   normalOrderedForm[] takes a product of SQSs and returns a (product of) SQS where indices of ptype are collected into one SQS in normal-ordered form.
The result is a CR of the form CR[sign,SQS]
*)

normalOrderedForm[str:NCM[__SQS],ptype_particleType] :=
    Module[ {rstr,permfac,ninds,ind,index},

		(* single string is by definition normal ordered *)
        If[ Length[str]==1,
            Return[CR[1,str[[1]]]]
        ];
        rstr = str;
        permfac = +1;
        (*
          Loop over strings, and move all indices of ptype to the first one
        *)
        (* # of indices of ptype in string 1 *)
        ninds = numIndicesOfType[rstr[[1]],ptype];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: ninds=",ninds]
        ];
        Do[
        	
        
        	ind = firstIndexOfType[rstr[[sL]],ptype];
        	While[ind!=-1,
        		index = rstr[[sL,ind]];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: rstr=",rstr//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: sL=",sL//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: ind=",ind//TraditionalForm]
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: index=",index//TraditionalForm]
        		];

        		(* drop this index from its current string ... *)
        		rstr[[sL]] = Drop[rstr[[sL]],{ind}];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after drop rstr=",rstr//TraditionalForm]
        		];

        		(* move creation indices to the front, move the annihilation indices to the back *)
        		If[ index[[3]]===indexType[cre],
            		rstr[[1]] = Prepend[rstr[[1]],index];
            		permfac*=(-1)^ninds;,
            		rstr[[1]] = Append[rstr[[1]],index];
        		];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after append rstr=",rstr//TraditionalForm]
        		];
        		ninds++;
        		ind = firstIndexOfType[rstr[[sL]],ptype];
        		If[ SeQuantDebugLevel>=8,
            		Print["in normalOrderedForm: after append ind=",ind//TraditionalForm]
        		];
        	];
       		If[ SeQuantDebugLevel>=8,
            	Print["in normalOrderedForm: moving on to next substring"]
        	];
        	,{sL,2,Length[rstr]}
        ];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: ready to chomp rstr=",rstr//TraditionalForm]
        ];
        rstr = chomp[rstr];
        If[ SeQuantDebugLevel>=8,
            Print["in normalOrderedForm: after chomp rstr=",rstr//TraditionalForm]
        ];
        Return[CR[permfac,rstr]];
    ];

normalOrderedForm[str_SQS,ptype_particleType] :=
    CR[1,str];

(*
  This function gets rid of empty strings and removes NCM if possible
*)
chomp[str:NCM[__SQS]] :=
    Module[ {rstr},
        rstr = str;

        (* remove empty strings *)
        rstr = Cases[rstr,Except[SQS[]]];
        rstr = rstr/.List->NCM;

        (* if only 1 string left -- remove NCM head *)
        If[ Length[rstr]==1,
            rstr = rstr[[1]]
        ];
        Return[rstr];
    ];

(* normal order for MultiConfiguration *)


normalOrderedForm[a_/;Head[a]=!=mSQS] :=
	a

normalOrderedForm[a_mSQS] := 
	Module[{sqs, cres, anns, pt, n,lp, lcs, lc, original, sign, contras, contra, tmplc, tmpann, tmpcre, tmpcontra, tmpop, tmpresult, ptmpresult, result},
		If [ a[[1]] === inorder,
			Return[a[[2]]]
		];
		If[ SeQuantDebugLevel>=8,
            Print["normal ordering   ", a //TraditionalForm]
        ];
		sqs = a[[2]];
		cres = creIndices[sqs];
		anns = annIndices[sqs];
		original = Join[cres, Reverse[anns]];
		n = Length[cres];
		Assert [ n === Length[anns] ];
		pt = contractionPattern[n];
		lp = Length[pt];
		contras = {};
		Do[
			contras = Join[ contras, uniquePattern[cres, anns, pt[[i]]] ];
			,{i,1,lp}
		];
	    lcs = Length[contras];	
	    result = Plus[];
	    Do [
	    	contra = contras[[i]];
	    	
	    	If [ SeQuantDebugLevel >= 9,
        		Print [ " contraction pattern \n" , contra //TraditionalForm ]
        	];

	    	sign = signrule[original, contra];
	    	
	    	If [ SeQuantDebugLevel >= 10,
        		Print [ " permutation of this pattern:    " , sign ]
        	];
        	
	    	lc = Length[ contra ];
	    	tmpresult = 1;
			(* full contraction *)
	    	Do [
	    		tmplc = Length[contra[[j]] ]/2;
	    		tmpcre = Take[contra[[j]], tmplc ];
	    		tmpann = Take[contra[[j]], - tmplc];
	    		
	    		If [ contractIndex[ contra[[j]] ],
	    			tmpcontra = createSQM["\[Lambda]",tmpann, tmpcre,antisymm],
	    			tmpcontra = 0
	    		];
	    		
	    		If [ SeQuantDebugLevel >= 10,
        			Print [ "       result of contraction:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =  ", tmpcontra //TraditionalForm ]
        		];
        		
	    		tmpresult = tmpresult * tmpcontra;
	    		,{j, 1, lc}
	    	];
	    	
	    	If [ SeQuantDebugLevel >= 9,
            	Print[ " full contraction in this pattern:    ", sign * tmpresult //TraditionalForm ]
            ];
            
	    	result = Plus[result, sign*tmpresult];
	    	(* partial contraction *)
	    	tmpresult = Plus[];
	    	Do[
	    		tmplc = Length[contra[[j]] ] /2;
	    		tmpcre = Take[contra[[j]], tmplc ];
	    		tmpann = Take[contra[[j]], - tmplc];
	    		tmpop = createSQS[tmpcre, tmpann];	
	    		
	    		If [ SeQuantDebugLevel >= 10,
        			Print [ "       result of the operator:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =   ", tmpop //TraditionalForm ]
        		];
        	
        		ptmpresult = 1;
        		
	    		Do[
	    			If [ k =!= j,
	    				tmplc = Length[contra[[k]] ]/2;
	    				tmpcre = Take[contra[[k]], tmplc ];
	    				tmpann = Take[contra[[k]], - tmplc];
	    				If [ contractIndex[contra[[k]]],
	    					tmpcontra = createSQM["\[Lambda]",tmpann, tmpcre, antisymm],
	    					tmpcontra = 0
	    				];			
	    				
	    				If [ SeQuantDebugLevel >= 10,
        					Print [ "       result of contraction:  " , tmpcre //TraditionalForm, "  and  " , tmpann //TraditionalForm, "  =  ", tmpcontra //TraditionalForm ]
        				];
        				
		    			ptmpresult = ptmpresult * tmpcontra
	    			]; 	
	    			,{k,1,lc}	
	    		];
        		
	    		tmpresult = Plus[tmpresult, sign*ptmpresult*tmpop];
	    		,{j,1,lc}
	    	];
	    	
	    	If [ SeQuantDebugLevel >= 9,
        		Print[ " partial contraction in this pattern:    ", tmpresult //TraditionalForm ]
        	];
	    	result = Plus[result, tmpresult];
	    	,{i, 1, lcs}
	    ];
	    (* zeroDensity[result]; *)
	    
	    If[ SeQuantDebugLevel>=8,
            Print["normal ordered form   ", result //TraditionalForm]
        ];
        
		Return[result];
	];
	
(* function to deal with the sign rule for MultiConfiguration *)

(* parity of permutation for sign rule *)
permutationSignature[perm_?PermutationCyclesQ] := 
 Apply[Times, (-1)^(Length /@ First[perm] - 1)]

(* sign rule function for MultiConfiguration *)
signrule[original_List, pattern_List] := 
 	Module[{lp,cres, anns, new, l1, l2, sign}, 
  		lp = Length[ pattern ];
  		cres = {};
  		anns = {};
  		Do[
  			cres = Join[cres, Take[pattern[[i]], Length[pattern[[i]]]/2  ] ];
  			anns = Join[anns, Take[pattern[[i]], -Length[pattern[[i]]] /2  ] ];
  			,{i, 1, lp}
  		];
  		new = Join[cres, Reverse[anns] ];
  		If [ new === original,
			Return[1];  			
  		];
  		l1 = Length[original];
   		l2 = Length[new];
   		Assert[l1 === l2];
   		sign = permutationSignature[ FindPermutation[original, new] ];
   		Return[sign];
   	];




(* ::Section::Closed:: *)
(* Wick Class  *)


(*
wick applies Wick's theorem to arbitrary SQ expressions

since SQS do not generally commute with each other the NonCommutativeMultiply (**) has
to be used in such expressions
*)
wick::wrongargs = "Wrong arguments given to wick";
Unprotect[defaultWickOptions];
defaultWickOptions = 	
{
	fullContract->True,
	noCoincidences->False,
	useDensity->True,
	doSums->True,
	doReindex->True
};
Protect[defaultWickOptions];

wick[expr_,extInds_List,wickOptions_List:defaultWickOptions] :=
    Module[ {result, newexpr, options, intinds, extinds},
        options = Cases[wickOptions,x_/;!FreeQ[x,fullContract]];
        intinds = Sort[indexListOut[expr,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Wick options:"];
            Print[options];
            Print["Internal indices before wick"];
            Print[intinds//TraditionalForm];
        ];
        extinds = Sort[extInds];
        If[ SeQuantDebugLevel>=1,
            Print["External indices:",extinds//TraditionalForm];
        ];
        
        (* 
        in MultiConfiguration, check mSQS if in normal order form. 
        If not, convert it into normal order form
         *)
        If[ SeQuantVacuum === SeQuantVacuumChoices["MultiConfiguration"],
        	
        	If[ SeQuantDebugLevel>=1,
            	Print ["Before normal ordering  ", expr //TraditionalForm ];
        	];
        	
        	Unprotect[NonCommutativeMultiply];
        	newexpr = Map[normalOrderedForm,expr,Infinity];
        	newexpr = Map[Distribute,newexpr,Infinity];
        	Protect[NonCommutativeMultiply];
        	
        	If[ SeQuantDebugLevel>=1,
            	Print ["After normal ordering  ", newexpr //TraditionalForm ];
        	];
        ];
        
        (* do wick theorem here *)
        If[ SeQuantVacuum === SeQuantVacuumChoices["MultiConfiguration"],
        	result = lowwick[newexpr, options],	
        	result = lowwick[expr,options]
        ];
        
        If[ SeQuantDebugLevel>=1,
            Print["After wick"];
            Print[result//TraditionalForm];
        ];
        
        (* expand result here*)
        If[ SeQuantVacuum === SeQuantVacuumChoices["MultiConfiguration"],
        	result = expandExp[result];
        	result = Map[Distribute,result,{0,Infinity}];
        	If[ SeQuantDebugLevel>=1,
            	Print["After Expand"];
            	Print[result//TraditionalForm];
        	];
        ];
        
		(* convert cumulant to density
        	only works for cumulant of rank 1 and 2
        	cumulant of rank higher than 2 is avoided to be caculated
        *)
        If[ SeQuantVacuum === SeQuantVacuumChoices["MultiConfiguration"] && useDensity/.wickOptions,
        	result = convertExp[result];
        	result = Map[Distribute,result,{0,Infinity}];
        	If[ SeQuantDebugLevel>=1,
            	Print["After Convert"];
            	Print[result//TraditionalForm];
        	];
        ];
        
        
        (* New internale indices may have been generatd by lowwick -- recompute *)
        intinds = Sort[indexListOut[result,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Internal indices after wick"];
            Print[intinds//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["Before reduceWick"];
            Print[result//TraditionalForm];
        ];
        If[ doSums/.wickOptions,
            result = reduceWick[result,extinds,intinds]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["After reduceWick"];
            Print[result//TraditionalForm]
        ];
        
        (* New internale indices may have been generatd by reduceWick -- recompute *)
        intinds = Sort[indexListOut[result,extInds]];
        If[ SeQuantDebugLevel>=1,
            Print["Internal indices after wick and reduce"];
            Print[intinds//TraditionalForm]
        ];
        If[ noCoincidences/.wickOptions,
            result = result/.x_deltaIndex->0
        ];
        If[ SeQuantDebugLevel>=1,
            Print["Before reindex"];
            Print[result//TraditionalForm];
            Print[intinds//TraditionalForm]
        ];
        If[ doReindex/.wickOptions,
            result = reindex[result,intinds]
        ];
        If[ SeQuantDebugLevel>=1,
            Print["After reindex"];
            Print[result//TraditionalForm]
        ];

                
        Return[result];
    ];


(* commutator
	it is just a**b - b**a at current stage
 *)
commute[a_, b_] :=
	a**b - b**a



(* ::Subsection:: *)
(* lowwick funciton *)


(* recursively comupte each term in expression *)
lowwick[a_+b_,contractOptions_List] :=
    Module[ {resulta,resultb},
        resulta = lowwick[a,contractOptions];
        resultb = lowwick[b,contractOptions];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): arg1=",a//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): wick(arg1)=",resulta//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): arg2=",b//TraditionalForm]
        ];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(+): wick(arg2)=",resultb//TraditionalForm]
        ];
        Return[resulta+resultb]
    ];

lowwick[(a_/;FreeQ[a,SQS])*b_,contractOptions_List] :=
    a*lowwick[b,contractOptions];

lowwick[a_SQM,contractOptions_List] :=
    a;

lowwick[str_SQS,contractOptions_List] :=
    contractSQSNTypes[NCM[str],contractOptions];

lowwick[(str_NCM/;!FreeQ[str,Plus]),contractOptions_List] :=
    Module[ {result,dstr},
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): arg=",str//TraditionalForm]
        ];
        dstr = Map[Distribute,str,{0,Infinity}];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): dist(arg)=",dstr//TraditionalForm]
        ];
        result = lowwick[dstr,contractOptions];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick(distribute): result=",result//TraditionalForm]
        ];
        Return[result]
    ];

lowwick[str_NCM,contractOptions_List] :=
    Module[ {result,containsSQS,f},
        Clear[containsSQS];
        Clear[f];
        If[ SeQuantDebugLevel>=6,
            Print["in lowwick: arg=",str//TraditionalForm]
        ];
        pfac = 1;
        result = NCM[];
        f[(a_/;FreeQ[a,SQS])*b_SQS] :=
            (pfac*=a;
             result = Append[result,b]);
        f[(a_/;FreeQ[a,SQS])*b_NCM] :=
            (pfac*=a;
             f[b]);
        f[(a_/;FreeQ[a,SQS])*b_SQM] :=
            (pfac*=a*b);
        f[b_NCM] :=
            (Map[f,b]);
        f[b_SQS] :=
            (result = Append[result,b]);
        f[b_SQM] :=
            (pfac*=b);
        Map[f,str];
        If[ SeQuantDebugLevel>=5,
            Print["in lowwick: fact(arg)=",pfac*result//TraditionalForm]
        ];
        result = If[ result===NCM[],
                     Expand[pfac],
                     Expand[pfac*contractSQSNTypes[result,contractOptions]]
                 ];
        If[ SeQuantDebugLevel>=5,
            Print["in lowwick: wick(arg)=",result//TraditionalForm]
        ];
        Return[result];
    ];


(* ::Subsection:: *)
(* reduceWick *)


(*
Reduction routines

reduceWick is the top-level routine that reduces expressions
    produced by wick by carrying out summations over internalIndices
lowReduceWick is the low-level summation routine
*)
Unprotect[defaultReduceOptions];
defaultReduceOptions = {};
Protect[defaultReduceOptions];

reduceWick[expr_,externalIndices_List:{},internalIndices_List:{},reduceOptions_List:defaultReduceOptions] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[expr];
        If[ Head[expr]===Plus,
            result = 0;
            Do[
            	GlobalIndexCounter = 0;
            	result+=lowReduceWick[expr[[i]],externalIndices,internalIndices,reduceOptions],{i,1,nterms}
            ],
            result = lowReduceWick[expr,externalIndices,internalIndices,reduceOptions]
        ];
        Return[result];
    ];

lowReduceWick[expr_,externalIndices_List,internalIndices_List,reduceOptions_List] :=
    Module[ {deltaReplInt,deltaReplExtA,deltaReplExtB,result,indI,indJ,spaceI,spaceJ,spaceK,indK,extI,pairIJ,havedeltaIJ,havedeltaJI},
        deltaReplInt = {};
        deltaReplExtA = {};
        deltaReplExtB = {};
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: expr = ",expr//TraditionalForm];
            Print["In lowReduceWick: internalIndices = ",internalIndices//TraditionalForm];
        ];

        (* Reducing Kronecker delta's uses 2 rules:
        1) if it binds 2 internal (summed-over) indices I and J, replace them with a new internal index representing intersection of spaces of I and J, !!remove delta!!
        2) if it binds an internal (summed-over) index J and external index I:
        2a) if space of J includes space of I, replace J with I, !!remove delta!!
        2b) If space of J is a subset of space of I, replace J with a new internal index represenating intersection of spaces of I and J, !!keep the delta!!
        *)
        Do[
        	indI = internalIndices[[intI]];
        	spaceI = indexSpace[indI];
        	Do[
        		indJ = internalIndices[[intJ]];
        		spaceJ = indexSpace[indJ];
        		havedeltaIJ = deltaQ[expr,deltaIndex[indI,indJ]];
        		havedeltaJI = deltaQ[expr,deltaIndex[indJ,indI]];
        		If[ !havedeltaIJ&&!havedeltaJI,
           	 		Continue[]
        		];
        		spaceK = Intersection[spaceI,spaceJ];
        		If[ spaceI===spaceK,
            		indK = indI,
            		If[ spaceJ===spaceK,
                		indK = indJ,
                		indK = createParticleIndex[spaceK]
            		]
        		];
        		pairIJ = {indK,indI,indJ};
        		deltaReplInt = Append[deltaReplInt,pairIJ];
        		,
        		{intJ,intI+1,Length[internalIndices]}
        	],
        	{intI,1,Length[internalIndices]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick:  int-int delta replacement = ",deltaReplInt//TraditionalForm];
        ];
        Do[ (* loop over a (ext,int) pair *)
        	indI = externalIndices[[extI]];
        	spaceI = indexSpace[indI];
        	Do[
        		indJ = internalIndices[[intJ]];
        		spaceJ = indexSpace[indJ];
        		havedeltaIJ = deltaQ[expr,deltaIndex[indI,indJ]];
        		havedeltaJI = deltaQ[expr,deltaIndex[indJ,indI]];
        		If[ !havedeltaIJ&&!havedeltaJI,
            		Continue[]
        		];
        		spaceK = Intersection[spaceI,spaceJ];
        		indK = If[ spaceI===spaceK,
            		indI,
            		If[ spaceJ===spaceK,
                		indJ,
                		createParticleIndex[spaceK]
            		]
        		];
        		pairIJ = {indK,indI,indJ};
       		 	If[ spaceI===spaceK,
            		deltaReplExtA = Append[deltaReplExtA,pairIJ],
            		deltaReplExtB = Append[deltaReplExtB,pairIJ]
        		];
        		,
        		{intJ,1,Length[internalIndices]}
        	],
        	{extI,1,Length[externalIndices]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick:  ext-in-int delta replacement = ",deltaReplExtA//TraditionalForm];
            Print["In lowReduceWick:  ext-int delta replacement = ",deltaReplExtB//TraditionalForm];
        ];
        result = expr;
        Do[
        	indK = deltaReplInt[[i,1]];
        	indI = deltaReplInt[[i,2]];
        	indJ = deltaReplInt[[i,3]];
        	result = result/.deltaIndex[a_,b_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.deltaIndex[b_,a_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplInt]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after int-int reduction: result = ",result//TraditionalForm];
        ];
        Do[
        	indK = deltaReplExtA[[i,1]];
        	indI = deltaReplExtA[[i,2]];
        	indJ = deltaReplExtA[[i,3]];

        	result = result/.deltaIndex[a_,b_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.deltaIndex[b_,a_]/;indexEquiv[indI,a]&&indexEquiv[indJ,b] ->1;
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplExtA]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after ext-in-int reduction: result = ",result//TraditionalForm];
        ];
        Do[
        	indK = deltaReplExtB[[i,1]];
        	indI = deltaReplExtB[[i,2]];
        	indJ = deltaReplExtB[[i,3]];
        	result = result/.indII_particleIndex:>createParticleIndex[indII,indK[[1]],indK[[2]]]/;((indII[[1]]==indJ[[1]])&&(indII[[2]]==indJ[[2]]));
        	,{i,1,Length[deltaReplExtB]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowReduceWick: after ext-int reduction: result = ",result//TraditionalForm];
        ];
        Return[result];
    ];


(*
Transformation routines

orderedForm puts elements of SQ expressions (SQ strings SQS and matrix elements SQM) into their "canonical " form. 
The canonical order of indices of each type (that belong to the same space) is alphabetical. 
This is where the permutational symmetry of SQM's matters.
*)

orderedForm[str_SQS,intInds_List:{}] :=
    Module[ {result,permfac,creInds,annInds},
        permfac = 1;
        creInds = Cases[str,a_particleIndex/;a[[3]]==indexType[cre]];
        permfac*=Signature[creInds];
        creInds = Sort[creInds];
        annInds = Cases[str,a_particleIndex/;a[[3]]==indexType[ann]];
        annInds = Reverse[annInds];
        permfac*=Signature[annInds];
        annInds = Sort[annInds];
        result = permfac*FlattenAt[SQS[FlattenAt[{creInds,Reverse[annInds]},{{1},{2}}]],{1}];
        Return[result];
    ];


orderedForm[oper_SQM,intInds_List:{}] :=
    Module[ {result,symfac,permfac,operHead,braInds,ketInds},
        symfac = Cases[oper,_indexSymm,Infinity][[1,1]];
        If[ symfac==0,
            Return[oper]
        ];
        permfac = 1;
        operHead = Cases[oper,_OHead][[1]];
        result = oper;

        (* 
        canonical order prioritizes external indices over internal
        to achieve this tag all internal indices such that their Length is greater, then external indices will come first
        *)
        result = tagIndices[oper,intInds];
        braInds = Cases[result,a_particleIndex/;a[[3]]==indexType[bra]];
        If[ symfac==-1,
            permfac*=Signature[braInds]
        ];
        braInds = Sort[braInds];
        ketInds = Cases[result,a_particleIndex/;a[[3]]==indexType[ket]];
        If[ symfac==-1,
            permfac*=Signature[ketInds]
        ];
        ketInds = Sort[ketInds];
        result = FlattenAt[SQM[FlattenAt[{braInds,ketInds},{{1},{2}}]],{1}];
        result = Prepend[result,operHead];
        result*=permfac;
        result = untagIndices[result,intInds];
        Return[result];
    ];

(* maporder function with no indecis *)
maporder[a_SQS] := ( orderedForm[a,{}] ); 

maporder[a_SQM] := ( orderedForm[a, {}] );

maporder[a_/;(Head[a]=!=SQS && Head[a]=!=SQM) ] :=
	a;
	
	
(* low-level function that produces the list of unique indices from expr which are present in intInds *)
indexListIn[expr_,intInds_List] :=
    Module[ {intIndsIn},
        intIndsIn = {};
        Do[
        	If[ indexQ[expr,intInds[[i]] ]&&!indexQ[intIndsIn,intInds[[i]]],
            	intIndsIn = Append[intIndsIn,intInds[[i]]]
        	],
        	{i,1,Length[intInds]}
        ];
        Return[intIndsIn];
    ];

(* low-level function that produces the list of unique indices from expr which are not present in intInds *)
indexListOut[expr_,intInds_List] :=
    Module[ {indsOut,indsAll,a},
        indsOut = {};
        indsAll = Cases[expr,x_particleIndex,Infinity];
        Do[
        	a = indsAll[[i]];
        	If[ !indexQ[intInds,a]&&!indexQ[indsOut,a],
            	indsOut = Append[indsOut,a]
        	],
        	{i,1,Length[indsAll]}
        ];
        Return[indsOut];
    ];


(* ::Section::Closed:: *)
(* Reindexing  *)


(*
Reindexing routines

reindex is the top-level reindexing routine
lowreindex is the low-level routine
*)
reindex[expr_,intInds_List:{}] :=
    Module[ {result, maporder, ordexpr,tmpexpr,i},
        result = 0;

(* If result is a constant -- no need to reindex *)
        If[ FreeQ[expr,SQM]&&FreeQ[expr,SQS],
            Return[expr]
        ];

        (* Put SQS's and SQM's in expr into their canonical form *)
        maporder [a_SQS] := ( orderedForm[a, intInds] );
        maporder [a_SQM] := ( orderedForm[a, intInds] );
        maporder [a_/;(Head[a]=!=SQS && Head[a]=!=SQM) ] :=
        	 a;
        ordexpr = Map[maporder, expr,2];
		
        (* Reorder SQS's and SQM's

        Times orders expressions automatically according to the canonical order

        The canonical order that we want is determined by external indices only  so that
        the subsequent call to lowreindex can
        simplify results the most.
        *)
        (* Replace Times with NCM and reorder into "new " canonical order*)
        ordexpr = ordexpr/.Times->NCM;
        (*Print["Before new canon ord"];
        Print[ordexpr//TraditionalForm];*)
        tmpexpr = 0;
        If[ Head[ordexpr]===Plus,
            Do[tmpexpr+=newcanonord[ordexpr[[i]],intInds],{i,Length[ordexpr]}],
            tmpexpr = newcanonord[ordexpr,intInds]
        ];
        ordexpr = tmpexpr;
        (*Print["In new canon ord"];
        Print[ordexpr//TraditionalForm];*)

        (*
        Rename internal indices using the canonical list for each index space

        Right now there's no additional reordering of internal indices prior to reindexing. This should be OK
        as long as no 6-index quantities appear in the expression. If that happens then as additional reordering
        of internal indices needs to be performed. The algorithms for that is as follows:
        1. within each SQS/SQM order internal indices which appear in the expression for the first time according to the index of the SQS/SQM in which this index appears next. If multiple internal indices from the current SQS/SQM appear in a nonsymmetric SQM later in the expression, order is determined by the relative position of the indices in that SQM.

        I think what I do now is OK if no 3-body operators or excitations are considered.
        *)
        If[ Head[ordexpr]===Plus,
            Do[result+=lowreindex[ordexpr[[i]],intInds],{i,Length[ordexpr]}],
            result = lowreindex[ordexpr,intInds]
        ];
        (*Print["After lowreindex"];
        Print[result//TraditionalForm];*)

        (* NCM can be changed back to Times now *)
        result = result/.NCM->Times;

        (* In case some SQS's or SQM's are not canonicalized - canonicalize again *)
        result = Map[maporder, result,2];
        Return[result];
    ];

lowreindex[expr_,intInds_List] :=
    Module[ {result,transexpr,indexlist,canonord,pairlist,ind,space,i},
        If[ Length[intInds]==0,
            Return[expr]
        ];
        (* Form canonically ordered lists *)
        Do[
        	ind = intInds[[i]];
        	space = Cases[intInds[[i]],_particleSpace][[1]];
        	If[ Head[canonord[space]]=!=List,
            	canonord[space] = {}
        	];
        	If[ !MemberQ[canonord[space],ind],
            	canonord[space] = Append[canonord[space],ind]
        	],
        	{i,Length[intInds]}
        ];

       	(* Transform layout of SQS's so that the grand index list is pretty; we want external indices to come first in creation list, but last in the annihilation list
        *)
        If[ Head[expr]=!=SQS&&!FreeQ[expr,SQS],(*transexpr=Cases[expr,x_SQS:>FlattenAt[SQS[FlattenAt[{Level[Select[x,indexCreQ],1],Reverse[Level[Select[x,indexAnnQ] ,1]]},{{1},{2}}]],{1}]]*)
            transexpr = expr/.x_SQS:>FlattenAt[SQS[FlattenAt[{Level[Select[x,indexCreQ],1],Reverse[Level[Select[x,indexAnnQ] ,1]]},{{1},{2}}]],{1}],
            transexpr = expr
        ];
        If[ Head[expr]===SQS,
            transexpr = FlattenAt[SQS[FlattenAt[{Level[Select[expr,indexCreQ],1],Reverse[Level[Select[expr,indexAnnQ] ,1]]},{{1},{2}}]],{1}]
        ];

        (* Get the grand list of all indices in the expression *)
        indexlist = Cases[transexpr,x_particleIndex,Infinity];

        (* For each internal index in indexlist find its canonicalized counterpart and form the list of (old,new) pairs *)
        pairlist = {};
        tmpintinds = intInds;
        If[ SeQuantDebugLevel>=2,
            (
           	Print["In lowreindex: transformed expression = ",transexpr//TraditionalForm];
            Print["In lowreindex: grand index list = ",indexlist//TraditionalForm];
            Print["In lowreindex: internal index list = ",intInds//TraditionalForm]
            )
        ];
        Do[
        	ind = indexlist[[i]];
        	space = indexSpace[ind];
        	If[ indexQ[tmpintinds,ind],
            	(If[ !indexEquiv[ind,canonord[space][[1]]],
                 	pairlist = Append[pairlist,{createParticleIndex[ind[[1]],ind[[2]]],canonord[space][[1]]}]
             	];
             	canonord[space] = Drop[canonord[space],1];
             	tmpintinds = DeleteCases[tmpintinds,x_particleIndex/;indexEquiv[x,ind],Infinity]
            	)
       		 ],
        	{i,Length[indexlist]}
        ];
        If[ SeQuantDebugLevel>=2,
            Print["In lowreindex: internal index replacement list = ",pairlist]
        ];

        (* Use pairlist to replace indices *)
        result = expr;
        Do[
        	indI = pairlist[[i,1]];
        	indJ = pairlist[[i,2]];
        	(* Replacement in deltaIndex and in SQM/SQS work slightly differently *)
        	result = result/.indII_particleIndex:>particleIndex[indJ[[1]],indJ[[2]],indII[[3]],"newIndex"]/;(Length[indII]>2&&FreeQ[indII,"newIndex"]&&(indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	result = result/.indII_particleIndex:>particleIndex[indJ[[1]],indJ[[2]],"newIndex"]/;(Length[indII]==2&&FreeQ[indII,"newIndex"]&&(indII[[1]]==indI[[1]])&&(indII[[2]]==indI[[2]]));
        	,{i,1,Length[pairlist]}
        ];

        (* get rid of temporary "newIndex " tags on replaced indices *)
        result = result/.indII_particleIndex:>particleIndex[indII[[1]],indII[[2]]]/;(Length[indII]==3&&!FreeQ[indII,"newIndex"]);
        result = result/.indII_particleIndex:>particleIndex[indII[[1]],indII[[2]],indII[[3]]]/;(Length[indII]>3&&!FreeQ[indII,"newIndex"]);
        Return[result];
    ];

newcanonord[0, _List] :=
    0;
newcanonord[expr_SQS|expr_SQM,intInds_List] :=
    expr;
newcanonord[expr_NCM,intInds_List] :=
    Module[ {neword,tmpexpr,reordlist,i},
(*
Put elements that contain external indices at the beginning. If two elements
contain same number of external indices order according to the standard Order[] 

This strategy will only work in simple cases
*)
        tmpexpr = expr/.a_particleIndex:>1/;indexQ[intInds,a];
        neword[a_,b_] :=
            Module[ {result,na,nb},
                na = Length[Cases[a,x_particleIndex/;!indexQ[intInds,x]]];
                nb = Length[Cases[b,x_particleIndex/;!indexQ[intInds,x]]];
                result = If[ na>nb,
                             True,
                             If[ na<nb,
                                 False,
                                 Order[a,b]>=0
                             ]
                         ];
                Return[result];
            ];
        reordlist = Ordering[tmpexpr,Length[tmpexpr],neword];
        tmpexpr = expr[[ reordlist[[1]] ]];
        Do[tmpexpr = tmpexpr**expr[[ reordlist[[i]] ]],{i,2,Length[reordlist]}];
        Return[tmpexpr];
    ];


(*
Remove diconnected terms. Connectedness is determined with respect to the Hamiltonian
*)

removeDisconnectedTerms[expr_,externalIndices_List:{},hamiltonianOpers_List:defaultHamiltonianOpers] :=
    Module[ {result,nterms},
        result = 0;
        nterms = Length[expr];
        If[ Head[expr]===Plus,
            result = 0;
            Do[
            GlobalIndexCounter = 0;
            result+=lowRemoveDisconnectedTerms[expr[[i]],externalIndices,hamiltonianOpers],{i,1,nterms}],
            result = lowRemoveDisconnectedTerms[expr,externalIndices,hamiltonianOpers]
        ];
        Return[result];
    ];

	
lowRemoveDisconnectedTerms[expr_,externalIndices_List,hamiltonianOpers_List] :=
    Module[ {intIndices,SQMs,tags,itag,nsqm,hindex,nh,result,listcopy,done,ariadna,noTags},
(* If there are no SQMs, there are no disconnected terms *)
        If[ FreeQ[expr,SQM],
            Return[expr]
        ];
        intIndices = indexListOut[expr,externalIndices];
        SQMs = getSQMList[expr];
        (* ignore some operators if need the rest to be fully connected *)
        SQMs = Select[SQMs,Count[ignoreConnectedOpers,#[[1,1]]]==0&];
        nsqm = Length[SQMs];
        tags = Table[False,{i,1,nsqm}];
        nh = Length[hamiltonianOpers];
        (* find the hamiltonian matrix element *)
        hindex = -1;
        Do[
        Do[
        If[ SQMs[[m,1,1]]==hamiltonianOpers[[h]],
            hindex = m;
            Break
        ]
        ,{m,1,nsqm}
        ];
        If[ hindex!=-1,
            Break
        ],
        {h,1,nh}
        ];
        If[ hindex==-1,
            Print["SeQuant Abort: lowRemoveDisconnectedTerms: Hamiltonian operator is not found"];
            Abort[]
        ];
        listcopy = SQMs;
        done = 0;
        (* tag indices recursively starting with h until all exhausted *)
        itag = hindex;
        ariadna = {}; (* keeps track of the path from the hamiltonian *)
        While[done==0,
        result = tagSQMInList[itag,listcopy,tags,intIndices];
        If[ Length[result]==3,
        (*Print["Result=",result//TraditionalForm];*)
            ariadna = Append[ariadna,itag];
            itag = result[[1]];
            listcopy = result[[2]];
            tags = result[[3]]
        ];
        If[ Length[result]==2,
        (*Print["Result=",result//TraditionalForm];*)
            tags = result[[2]];
            done = 1
        ];
        (*Print["Ariadna=",ariadna];*)
        If[ result==-1,
            done = 1
        ];
        (* If current node not connected to other untagged nodes, step back along the thread towards h,unless just started from h (dist==0) *)
        If[ done==1&&Length[ariadna]!=0,
            itag = Last[ariadna];
            ariadna = Drop[ariadna,-1];
            done = 0
        ];
        ];
        (* if some nodes are on the ignore list, tag them *)
        Do[If[ tags[[o]]==False&&Count[ignoreDisconnectedOpers,SQMs[[o,1,1]]]>0,
               tags[[o]] = True
           ],{o,1,nsqm}];
        noTags = Select[tags,#==False&];
        If[ Length[noTags]==0,
            Return[expr],
            Return[0]
        ];
    ];

getSQMList[expr_] :=
    Module[ {flatexpr,result},
        flatexpr = Flatten[expr];
        (* much simpler if the expression is an SQM itself *)
        If[ Head[flatexpr]===SQM,
            result = {flatexpr},
            result = Select[flatexpr,Head[#]==SQM&];
            (* for some reason Select may discard Head, e.g. when expr = Times[-1,SQM[OHead["F",indexSymm[-1]],particleIndex["\!\(a\_r\)",particleSpace[virtual],indexType[bra]],particleIndex["\!\(i\_r\)",particleSpace[occupied],indexType[ket]]]] *)
            result = If[ Head[result]===SQM,
                         {result},
                         result
                     ];
            result = Replace[result,Times->List,-1,Heads->True]
        ];
        Return[result];
    ];

tagSQMInList[icurr_,SQMs_List,Tags_List,IIndices_List] :=
    Module[ {nsqm,inext,ninds,current,iinds,niinds,iind,j,k,result,localtags},
(*Print["Will tag element ",icurr," in list ",SQMs//TraditionalForm," current tags are ",Tags];*)
        nsqm = Length[SQMs];
        current = SQMs[[icurr]];
        ninds = Length[current]-1;
        iinds = {};
        (* Find all internal indices connecting current SQM *)
        Do[
        j = current[[k+1]];
        If[ indexQ[IIndices,j],
            iinds = Append[iinds,j]
        ]
        ,{k,1,ninds}
        ];
        niinds = Length[iinds];
        localtags = Tags;
        localtags[[icurr]] = True;
        result = -1;
        (* Find an untagged SQM connected to i using index iind *)
        Do[
        If[ result!=-1,
            Break
        ];
        iind = iinds[[j]];
        Do[
        If[ k!=icurr,
            If[ indexQ[SQMs[[k]],iind],
                If[ localtags[[k]]==False,
                    inext = k;
                    localtags[[k]]==True;
                    result = {inext,SQMs,localtags};
                    Break;
                ]
            ]
        ]
        ,{k,1,nsqm}
        ],
        {j,1,niinds}
        ];
        If[ result==-1,
            result = {-1,localtags}
        ];
        Return[result];
    ];


(* ::Section::Closed:: *)
(* matching SQ *)


(*
Functions for pattern matching SQ expressions
*)

Unprotect[MatchQ];

MatchQ[a_particleIndex,b_particleIndex] :=
    Module[ {lb,result},
        lb = Length[b];
        result = True;
        Do[
        If[ Head[b[[i]]]=!=String,
            result = result &&!FreeQ[a,b[[i]]]
        ],
        {i,lb}
        ];
        Return[result];
    ];

MatchQ[a_SQS,b_SQS] :=
    Module[ {lb,result},
        lb = Length[b];
        If[ lb!=Length[a],
            Return[False]
        ];
        result = True;
        Do[
        result = result &&MatchQ[a[[i]],b[[i]]],
        {i,lb}
        ];
        Return[result];
    ];

MatchQ[a_SQM,b_SQM] :=
    Module[ {lb,result},
        lb = Length[b];
        If[ lb!=Length[a],
            Return[False]
        ];
        result = True;
        Do[
        If[ Head[b[[i]]]===OHead&&b[[i,1]]==="_",
            result = result&&True,
            result = result &&MatchQ[a[[i]],b[[i]]]
        ],
        {i,lb}
        ];
        Return[result];
    ];

(* Match SQ expressions *)
MatchQ[a_Times,b_Times] :=
    listMatchQ[ReplacePart[a,List,0],ReplacePart[b,List,0]];
MatchQ[a_Times,b_SQM] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_Times,b_SQS] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_NCM,b_NCM] :=
    listMatchQ[ReplacePart[a,List,0],ReplacePart[b,List,0]];
MatchQ[a_NCM,b_SQM] :=
    itemMatchQ[ReplacePart[a,List,0],b];
MatchQ[a_NCM,b_SQS] :=
    itemMatchQ[ReplacePart[a,List,0],b];

listMatchQ[a_List,b_List] :=
    Module[ {af,bf,lb,result,pos},
        If[ Length[b]==0,
            Return[True]
        ];
        (*af=Flatten[a];
        bf=Flatten[b];*)
        af = a;
        bf = b;
        lb = Length[bf];
        Print[Length[af]," ",lb];
        If[ lb>Length[af],
            Return[False]
        ];
        pos = Position[af,x_/;MatchQ[x,bf[[1]]],{0,Infinity},1];
        result = True;
        If[ pos=={},
            result = False,
            af = Delete[af,pos[[1]]];
            bf = Delete[bf,1];
            Print[af," ",bf];
            Print[Head[af],Head[bf]];
            result = MatchQ[af,bf];
        ];
        Return[result];
    ];

Protect[MatchQ];


(* ::Section::Closed:: *)
(* canonical MO *)


(*
Transform expressions assuming canonical MOs
NOTE: canonical MOs imply Brilluoin theorem
*)
canonMO[expr_,extInds_List] :=
    Module[ {result,intinds,extinds,maporder},
        intinds = Sort[indexListOut[expr,extInds]];
        extinds = Sort[extInds];
        result = brillouin[expr];
        result = lowcanonMO[result];
        result = reduceWick[result,extinds,intinds];
        
        maporder [a_SQS] := ( orderedForm[a, intinds] );
        maporder [a_SQM] := ( orderedForm[a, intinds] );
        maporder [a_/;(Head[a]=!=SQS && Head[a]=!=SQM) ] :=
        	 a;
        result = Map[maporder, result,2];
        Return[result];
    ];

lowcanonMO[expr_] :=
    Module[ {result,v,o,a,fvv,foo,faa,fock},
        v = createParticleIndex["_",virt];
        o = createParticleIndex["_",occ];
        a = createParticleIndex["_",any];
        fock = defaultHamiltonianOpers[[1]];
        fvv = createSQM[fock,{v},{v},antisymm];
        foo = createSQM[fock,{o},{o},antisymm];
        faa = createSQM[fock,{a},{a},antisymm];
        result = expr;
        (*result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,foo];
        result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,fvv];
        result=result/.a_SQM:>a*deltaIndex[a[[2]],a[[3]]]/;MatchQ[a,faa];*)
        result = result/.a_SQM:>(deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm])/;MatchQ[a,foo];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,fvv];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,faa];
        Return[result];
    ];

(*
Transform expressions assuming different versions of Brillouin theorem
*)
brillouin[expr_] :=
    Module[ {result,v,o,fvo,fov,fock},
        v = createParticleIndex["_",virt];
        o = createParticleIndex["_",occ];
        fock = defaultHamiltonianOpers[[1]];
        fvo = createSQM[fock,{v},{o},antisymm];
        fov = createSQM[fock,{o},{v},antisymm];
        result = expr;
        result = result/.a_SQM:>0/;MatchQ[a,fov];
        result = result/.a_SQM:>0/;MatchQ[a,fvo];
        Return[result];
    ];

(* includes standard Brillouin theorem *)
brillouinGen[expr_] :=
    Module[ {result,\[Alpha],o,f\[Alpha]o,fo\[Alpha],fock},
        \[Alpha] = createParticleIndex["_",allvirt];
        o = createParticleIndex["_",occ];
        fock = defaultHamiltonianOpers[[1]];
        f\[Alpha]o = createSQM[fock,{\[Alpha]},{o},antisymm];
        fo\[Alpha] = createSQM[fock,{o},{\[Alpha]},antisymm];
        result = expr;
        result = result/.a_SQM:>0/;MatchQ[a,fo\[Alpha]];
        result = result/.a_SQM:>0/;MatchQ[a,f\[Alpha]o];
        Return[result];
    ];

brillouinExt[expr_] :=
    Module[ {result,\[Alpha],v,f\[Alpha]v,fv\[Alpha],fock},
        \[Alpha] = createParticleIndex["_",allvirt];
        v = createParticleIndex["_",virt];
        fock = defaultHamiltonianOpers[[1]];
        f\[Alpha]v = createSQM[fock,{\[Alpha]},{v},antisymm];
        fv\[Alpha] = createSQM[fock,{v},{\[Alpha]},antisymm];
        result = expr;
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[2]] ]},{indexLight[ a[[2]] ]},antisymm]/;MatchQ[a,fv\[Alpha]];
        result = result/.a_SQM:>deltaIndex[a[[2]],a[[3]]]*createSQM[fock,{indexLight[ a[[3]] ]},{indexLight[ a[[3]] ]},antisymm]/;MatchQ[a,f\[Alpha]v];
        Return[result];
    ];


(*
Substitutes a second quantized tensor by the corresponding density matrix element.
*)
substituteSQSbyDensity[expr_] :=
    expr/.x_SQS->createSQM["\[Gamma]",annIndices[x],creIndices[x],antisymm];

(*
Zeroes out density matrix elements that include indices above the Fermi level
*)
zeroDensity[expr_] :=
    expr/.x_SQM/;x[[1,1]]=="\[Gamma]" &&
    MemberQ[x,y_particleIndex/;spaceWRTFermiLevel[indexSpace[y]]===+1]->0

(* toolkit is ready *)
Print["SeQuant is loaded and ready...\n"];

EndPackage[]




